{\rtf1\ansi\deff0
{\fonttbl{\f0\froman Times New Roman;}{\f1\froman Symbol;}}
{\colortbl;\red0\green0\blue255;\red0\green0\blue0;}
{\stylesheet{\fs28 \snext0 Normal;}
}\pard\plain
{\up $}{\footnote\pard\plain{\up $} About TCustomComPort version 2.63}
{\up #}{\footnote\pard\plain{\up #} 4BF7_AO}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} About TCustomComPort version 2.63}
\b\fs28 About ComPort Library version 2.63
\par \pard \plain\fs20 ComPort Library has been in development more than two years. There has been a lot of work put in this stuff. So i simply need some kind of motivation for further develpoment of ComPort Library. I would be very happy if you could take the time and send me a postcard from your country to my home address. I hope that is not too much to ask from you.
\par \fs16 
\par \b\fs20 ComPort Library help file version
\par \plain\fs20 2.63.1
\par \fs16 
\par \b\fs20 Author information
\par \plain\fs20 Name: Dejan Crnila
\par Year of birth: 1978
\par \pard Occupation: Student of computer and information science in University of Ljubljana
\par E-mail: \ul\cf1 dejancrn@yahoo.com\plain\fs20 
\par Home page: \ul\cf1 http://www2.arnes.si/~sopecrni\plain\fs20 
\par Home address: Dolenja vas 111, 3312 Prebold, SLOVENIA
\par \fs16 
\par \fs20 Special thanks to Paul Doland (E-mail: \ul\cf1 pdoland@flash.net\plain\fs20 ), who provided C++ Builder support for ComPort Library.
\par \fs16 
\par \b\fs20 Key features
\par \pard\li355\fi-355\tx355 \plain\f1\fs18 \'b7\tab \plain\fs20 Platforms: Windows NT 4.0, Windows 2000, Windows 95, Windows 98
\par \f1\fs18 \'b7\tab \plain\fs20 Languages: Delphi 3, 4, 5, 6 and C++ Builder 3, 4, 5
\par \f1\fs18 \'b7\tab \plain\fs20 Components: TComPort, TComDataPacket, TComComboBox, TComRadioGroup, TComLed, TComTerminal
\par \f1\fs18 \'b7\tab \plain\fs20 Asynchronous or synchronous Read/Write operations
\par \f1\fs18 \'b7\tab \plain\fs20 Detailed flow control settings
\par \f1\fs18 \'b7\tab \plain\fs20 Read/Write operation timeouts
\par \f1\fs18 \'b7\tab \plain\fs20 Use of multithreading for monitoring port events
\par \f1\fs18 \'b7\tab \plain\fs20 Build terminal application without a line of code
\par \pard\li355\fi-355\tx355 \f1\fs18 \'b7\tab \plain\fs20 Source code included (cca 7000 lines)
\par \f1\fs18 \'b7\tab \plain\fs20 A Delphi context-sensitive help file
\par \f1\fs18 \'b7\tab \plain\fs20 and much more \'85
\par \page
{\up $}{\footnote\pard\plain{\up $} What's new in version 2.63}
{\up #}{\footnote\pard\plain{\up #} 8NO.76}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} What's new in version 2.63}
\b\fs28 What's new in version 2.63\plain\fs24 
\par \pard \fs20 ComPort Libarary version 2.63 is not compatible with some older versions. Some methods and properties have been changed, so if you have been using older versions, you will have to change a code of your program a bit.
\par \fs16 
\par \b\fs20 New in version 2.63
\par \pard\li355\fi-355\tx355 \plain\f1\fs18 \'b7\tab \plain\fs20 Delphi 6 support
\par \f1\fs18 \'b7\tab \plain\fs20 TComStream class
\par \f1\fs18 \'b7\tab \plain\fs20 TComPort.EventThreadPriority property
\par \f1\fs18 \'b7\tab \plain\fs20 EnumComPorts non-admin (WinNT/2000) bug fixed
\par \f1\fs18 \'b7\tab \plain\fs20 Fixed hang up bug on port close
\par \f1\fs18 \'b7\tab \plain\fs20 Other minor fixes
\par \f1\fs18 \'b7\tab \plain\fs20 Optimization
\par \page
{\up $}{\footnote\pard\plain{\up $} Asynchronous and synchronous operations}
{\up #}{\footnote\pard\plain{\up #} 1ZIWXOX}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Asynchronous and synchronous operations}
\b\fs28 Asynchronous and synchronous operations
\par \pard \plain\fs20 Read and write operations on serial port can be performed in two modes, asynchronous or synchronous. In synchronous mode, method that peforms operation on port does not return until operation is completed (or aborted). In asynchronous mode, method returns immidiately and does not wait for the operation to be completed. After calling asynchronous operation, the result of the method might not yet be defined, so the application should call wait method to make sure the operation is completed. Between asynchronous call of operation and wait method, the application can perform any other tasks that are not dependend on asynchronous operation result.
\par \pard \fs16 
\par \fs20 Each asynchronous operation has to be prepared before it is performed. To prepare asynchronous operation, call \uldb InitAsync\plain\fs20 {\v PIWD4U} method. This method inits PAsync type paramater. Each method that deals with asynchronous operations has PAsync parameter. Use the same parameter as in InitAsnyc method, since the TCustomComPort has to know which operation it is refering to. After the operation is completed, call \uldb DoneAsync\plain\fs20 {\v 2_5VP2K} method to free the resources.
\par \fs16 
\par 
\par \ul\fs20 Example (asynchronous operation)
\par \pard \plain\fs16 
\par \b\fs20 var
\par \plain\fs20   Operation1: PAsync;
\par \fs16 
\par \b\fs20 begin
\par \plain\fs20   InitAsync(Operation1);
\par \b   try
\par \plain\fs20     ComPort1.WriteStrAsync('Hello', Operation1);
\par     \cf1 // do some stuff here
\par \plain\fs20     ComPort1.WaitForAsync(Operation1);
\par \b   finally
\par \plain\fs20     DoneAsync(Operation1);
\par \b   end\plain\fs20 ;
\par \b end\plain\fs20 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Opening and closing port}
{\up #}{\footnote\pard\plain{\up #} 1WIXSM4}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Opening and closing port}
\b\fs28 Opening and closing port
\par \pard \plain\fs20 Before most of the TCustomComPort methods can be succesfully called, serial port has to be opened. There are two ways to open serial port. Application can call \uldb Open\plain\fs20 {\v SMQ_I0} method or set \uldb Connected\plain\fs20 {\v 3JRPNVU} property to True. To end a session, call \uldb Close\plain\fs20 {\v 54QM.VP} method or set \uldb Connected\plain\fs20 {\v 3JRPNVU} property to False.
\par \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs20 begin
\par \plain\fs20   ComPort1.Open; \i\cf1 // open serial port\plain\fs20\cf1 
\par   \i // do some stuff here
\par \plain\fs20   ComPort1.Close; \i\cf1 // end session\plain\fs20\cf1 
\par \plain\b\fs20 end\plain\fs20 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Enumerating ports}
{\up #}{\footnote\pard\plain{\up #} 1KTGUC}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Enumerating ports}
\b\fs28 Enumerating ports
\par \pard \plain\fs20 Before setting serial port number, it is useful to call \uldb EnumComPorts\plain\fs20 {\v 1IVFZWT} procedure to enumerate serial ports on local machine. Application can then assign a member of TStrings result to \uldb Port\plain\fs20 {\v 1EW3.BP} property.
\par \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs20 begin
\par \plain\fs20   EnumComPorts(ComboBox1.Items);
\par   \i\cf1 // do some stuff
\par \plain\fs20\cf1   \plain\b\fs20 if\plain\fs20  ComboBox1.ItemIndex > -1 \b then\plain\fs20 
\par     ComPort1.Port := ComboBox1.Items[ComboBox1.ItemIndex];
\par \b end\plain\fs20 ;
\par 
\par \page
{\up $}{\footnote\pard\plain{\up $} Writing to port}
{\up #}{\footnote\pard\plain{\up #} SFMRV_}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Writing to port}
\b\fs28 Writing to port
\par \pard \plain\fs20 Write operations can be performed very easily when using TCustomComPort. There are four methods that deal with writing data.
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs20 Method\plain\fs20 \tab \tab \tab \b Description\plain\fs20 
\par \pard\tx355 Write\tab \tab \tab \tab Writes non-typed variable to output buffer.
\par WriteAsync\tab \tab \tab Writes non-typed variable to output buffer in.
\par \pard\li2115\fi705\tx355 asynchronous mode.
\par \pard\tx355 WriteStr\tab \tab \tab Writes string type variable to output buffer.
\par WriteStrAsync\tab \tab \tab Writes string type variable to output buffer in
\par \tab \tab \tab \tab \tab asnychronous mode.
\par \fs16 
\par \fs20 Application should also properly set write timeouts. See \uldb TComTimeouts\plain\fs20 {\v 1N1MC_O} class for more detailed description.
\par \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs20 var
\par \plain\fs20   Str: \b String\plain\fs20 ;
\par \fs16 
\par \b\fs20 begin
\par \plain\fs20   Str := 'Hello';
\par   ComPort1.WriteStr(Str); \i\cf1 // string type variable\plain\fs20 
\par   ComPort1.Write(Str[1], Length(Str)); \i\cf1 // no defined type\plain\fs20 
\par \pard\tx355 \b end\plain\fs20 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Reading from port}
{\up #}{\footnote\pard\plain{\up #} Y2GO0.}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Reading from port}
\b\fs28 Reading from port
\par \pard \plain\fs20 Reading from input buffer can be performed in two ways. Usually application calls one of the read methods inside \uldb OnRxChar\plain\fs20 {\v .1WU8Y} event, which triggers when charachter(s) arrive in input buffer. If read method is called inside OnRxChar event, read timeouts should be set to no wait, that is, read method checks input buffer and returns immidiately, since the number of bytes in input buffer is already known. Application can also call read method outside OnRxChar, but it should set read timeouts properly. See \uldb TComTimeouts\plain\fs20 {\v 1N1MC_O} for more details.
\par \pard \fs16 
\par \fs20 If component is linked to other component that needs incoming data, like \uldb TComDataPacket\plain\fs20 {\v 82GU66} or \uldb TCustomComTerminal\plain\fs20 {\v ZHXVI6}, OnRxChar event is is not called, however, the component calls \uldb OnRxBuf\plain\fs20 {\v 1HGAF55} event. The application can not read the data from input buffer inside OnRxBuf event, since it has already been read. The data is placed automatically by the component in Buffer parameter of OnRxBuf event. Whether OnRxChar or OnRxBuf event is called, can be checked with \uldb TriggersOnRxChar\plain\fs20 {\v 3YS4_IF} property.
\par \pard \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs20 Method\plain\fs20 \tab \tab \tab \b Description\plain\fs20 
\par \pard\tx355 Read\tab \tab \tab \tab Reads from input buffer to non-typed variable.
\par ReadAsync\tab \tab \tab Reads from input buffer to non-typed variable in
\par \pard\li2115\fi705\tx355 asynchronous mode.
\par \pard\tx355 ReadStr\tab \tab \tab Reads from input buffer to string type variable.
\par ReadStrAsync\tab \tab \tab Reads from input buffer to string type variable in
\par \tab \tab \tab \tab \tab asnychronous mode.
\par \fs16 
\par 
\par \ul\fs20 Example (inside OnRxChar)
\par \plain\fs16 
\par \b\fs20 procedure\plain\fs20  TForm1.ComPort1RxChar(Sender: TObject; Count: Integer);
\par \b var
\par \plain\fs20   Str: \b String\plain\fs20 ;
\par \b begin
\par \plain\fs20   ComPort1.ReadStr(Str, Count);
\par   \i\cf1 // do something with Str variable
\par \plain\b\fs20 end\plain\fs20 ;
\par \fs16 
\par 
\par \ul\fs20 Example (outside OnRxChar)
\par \plain\fs16 
\par \b\fs20 var
\par \pard\tx355 \plain\fs20   Str: \b String\plain\fs20 ;
\par \fs16 
\par \b\fs20 begin
\par \plain\fs20   \i\cf1 // set timeouts here or at design time
\par \plain\fs20   ComPort1.ReadStr(Str, NumberOfBytes);
\par   \i\cf1 // do something with Str variable
\par \plain\b\fs20 end\plain\fs20 ;
\par \fs16 
\par 
\par \ul\fs20 Example (inside OnRxBuf)
\par \plain\fs16 
\par \b\fs20 procedure\plain\fs20  TForm1.ComPort1RxBuf(Sender: TObject; const Buffer; Count: Integer);
\par \b begin
\par \plain\fs20   \i\cf1 // application does not have to read data from input buffer
\par \plain\fs20   \i\cf1 // data is already in buffer parameter
\par \plain\fs20   HandleData(Buffer, Count); \i\cf1 // handle data
\par \pard\tx355 \plain\b\fs20 end\plain\fs20 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Aborting asynchronous operations}
{\up #}{\footnote\pard\plain{\up #} 148L.AC}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Aborting asynchronous operations}
\b\fs28 Aborting asynchronous operation
\par \pard \plain\fs20 Asynchronous operations can easily be aborted. Unfortunately, a specific operation cannot be aborted, however, all operations in progress can be aborted simultaneously. If operation is aborted, \uldb WaitForAsync\plain\fs20 {\v 44HCXR} method raises \uldb EComPort\plain\fs20 {\v T2D5VU} exception with \uldb WinCode\plain\fs20 {\v 1.THX8K} property set to ERROR_OPERATION_ABORTED.
\par \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs20 var
\par \plain\fs20   Operation1: PAsync;
\par \fs16 
\par \b\fs20 begin
\par \plain\fs20   InitAsync(Operation1);
\par   \b try
\par \plain\fs20     ComPort1.WriteStrAsync('Hello', Operation1);
\par \pard     \i\cf1 // some stuff
\par \plain\fs20     \b if\plain\fs20  \i\cf1 \{\- some condition \'7d\plain\fs20  \b then\plain\fs20 
\par       ComPort1.AbortAllAsync;
\par     \i\cf1 // some stuff
\par \plain\fs20     ComPort1.WaitForAsync(Operation1);
\par   \b finally
\par \plain\fs20     DoneAsync(Operation1);
\par   \b end\plain\fs20 ;
\par \b end\plain\fs20 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Changing properties at runtime}
{\up #}{\footnote\pard\plain{\up #} 655TN3}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Changing properties at runtime}
\b\fs28 Changing properties at runtime
\par \pard \plain\fs20 All TCustomComPort properties except \uldb SyncMethod\plain\fs20 {\v 5Q.O_T7} can be changed at runtime while application is connected to serial port. Changes are applied immidiately. If \uldb Port\plain\fs20 {\v 1EW3.BP} property is changed while connected, serial port is closed and reopened. If properties are changed between \uldb BeginUpdate\plain\fs20 {\v B_D7I8} and \uldb EndUpdate\plain\fs20 {\v 9.E.CP} methods, changes are not applied until EndUpdate method is called. If you have to change more than one property at once, wrap them inside BeginUpdate, EndUpdate methods.
\par \pard \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs20 begin
\par \plain\fs20   ComPort1.Open;
\par \cf1   \i // do some stuff
\par \plain\fs20   ComPort1.FlowControl.ControlDtr := dtrEnable; \i\cf1 // changes are applied\plain\fs20\cf1 
\par   \i // do some stuff
\par \plain\fs16 
\par \fs20   BeginUpdate; \cf1 // prevent changes from being applied\plain\fs20 
\par   ComPort1.Parity.Bits := prOdd;
\par   ComPort1.FlowControl.XonXoffIn := True;
\par   EndUpdate; \cf1 // apply changes\plain\fs20 
\par \i\cf1   // do some stuff\plain\fs20 
\par   ComPort1.Close;
\par \b end\plain\fs20 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Storing and loading settings}
{\up #}{\footnote\pard\plain{\up #} XY_P6G}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Storing and loading settings}
\b\fs28 Storing and loading settings
\par \pard \plain\fs20 Application can easily store and load serial port settings using \uldb StoreSettings\plain\fs20 {\v 6YO5N.} and \uldb LoadSettings\plain\fs20 {\v G130FW} methods. Settings can be stored into configuration file or registry. \uldb StoredProps\plain\fs20 {\v 117OFJL} property determines which properties need to be stored.
\par \fs16 
\par 
\par \ul\fs20 Example (Registry)
\par \plain\fs16 
\par \b\fs20 begin
\par \plain\fs20   \cf1 // store settings to registry
\par \plain\fs20   ComPort1.StoreSettings(stRegistry, '\'5cHKEY_LOCAL_MACHINE\'5cSoftware\'5cComPortTest');
\par   \cf1 // load settings
\par \plain\fs20  ComPort1.LoadSettings(stRegistry, '\'5cHKEY_LOCAL_MACHINE\'5cSoftware\'5cComPortTest');
\par \pard \b end\plain\fs20 ;
\par \fs16 
\par \ul\fs20 Example (Configuration file)
\par \plain\fs16 
\par \b\fs20 begin
\par \plain\fs20   \cf1 // store settings to configuration file
\par \plain\fs20   ComPort1.StoreSettings(stIniFile, 'c:\'5cComPortTest.ini');
\par   \cf1 // load settings
\par \plain\fs20   ComPort1.LoadSettings(stIniFile, 'c:\'5cComPortTest.ini');
\par \b end\plain\fs20 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Using buffer functions}
{\up #}{\footnote\pard\plain{\up #} .88NCK}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Using buffer functions}
\b\fs28 Using buffer functions
\par \pard \plain\fs24 Application can clear input and/or ouput buffer using \uldb ClearBuffer\plain\fs24 {\v 1.9TBHL} method. Make sure that there is no asynchronous operation in progress while calling ClearBuffer, because it can cause unexpected problems.
\par \fs16 
\par 
\par \fs20 Example
\par \fs16 
\par \b\fs24 begin
\par \plain\fs24   \i\cf1 // do some stuff
\par \plain\fs24   \b if\plain\fs24  \i\cf1 \{\- some condition\'7d\plain\fs24\cf1  \plain\b\fs24 then\plain\fs24 
\par     ComPort1.ClearBuffer(True, False);  \i\cf1 // clear input buffer\plain\fs24 
\par \cf1   \i // do some stuff
\par \plain\b\fs24 end\plain\fs24 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Detecting signals and port state}
{\up #}{\footnote\pard\plain{\up #} 111JZN1}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Detecting signals and port state}
\b\fs28 Detecting signals and port state
\par \pard \plain\fs24 Change of signals (CTS, DSR, RLSD) can be detected using OnXChange events. Ring indicator can also be detected using \uldb OnRing\plain\fs24 {\v 1.0I3XO} event. Application can check the state of signals anytime with \uldb Signals\plain\fs24 {\v GXHHC} method.
\par \fs16 
\par \fs24 By calling \uldb StateFlags\plain\fs24 {\v BZP_YG} method, application can determine whether the transmission is in progress or in wait state due to some reason.
\par \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs24 procedure\plain\fs24  TForm1.ComPort1CTSChange(Sender: TObject; OnOff: Boolean);
\par \pard \b begin
\par \plain\fs24   \b if\plain\fs24  OnOff \b then\plain\fs24 
\par \fs20     PrintMessage('CTS high')
\par \fs24   \b else
\par \plain\fs24     \b if\plain\fs24  fCtlHold \b in\plain\fs24  ComPort1.StateFlags \b then  \plain\i\fs24\cf1 // if transmission is waiting\plain\fs24\cf1 
\par \plain\fs24       PrintMessage('CTS low, transmission waiting')
\par     \b else
\par \plain\fs24       PrintMessage('CTS low');
\par \b end\plain\fs24 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Changing output flow control signals}
{\up #}{\footnote\pard\plain{\up #} XEVRMN}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Changing output flow control signals}
\b\fs28 Changing output flow control signals
\par \pard \plain\fs24 Output flow control signals such as RTS and DTR can be handled manually, unless they are set to rtsHandshake and dtrHandshake. Use \uldb SetRTS\plain\fs24 {\v 2OD8.7P} and/or \uldb SetDTR\plain\fs24 {\v 2OD7Y7O} methods to set signals to low or high state. The same thing can be accomplished using FlowControl property during a session, but it is much faster if application uses SetX methods.
\par \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs24 begin
\par \plain\fs24   ComPort1.SetRTS(False); \i\cf1 // lower RTS signal\plain\b\fs24 
\par \plain\fs24   \i\cf1 // do some stuff
\par \plain\fs24   ComPort1.SetRTS(True); \i\cf1 // set RTS to high\plain\fs24 
\par \pard \b end\plain\fs24 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Retrieving error information}
{\up #}{\footnote\pard\plain{\up #} IBEDPA}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Retrieving error information}
\b\fs28 Retrieving error information
\par \pard \plain\fs24 When error occurs on serial port, \uldb OnError\plain\fs24 {\v 8RNVVL} event is triggered. Check Errors parameter of event to get information on error that occured on serial port. If application is not using OnError event, it can check last errors on port using \uldb LastErrors\plain\fs24 {\v 1KVBTD} method. LastErrors returns a set of error flags which indicate error type and clears error buffer. Therefore, if application calls LastErrors again, it returns empty result set, unless a new error occured between two calls. 
\par \pard \fs16 
\par \fs24 Application should not call LastErrors method inside OnError event, since it has already been called in inside TCustomComPort to set Errors parameter.
\par \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs24 procedure\plain\fs24  TForm1.ComPortError(Sender: TObject; Errors: TComErrors);
\par \b begin
\par \plain\fs24   \b if\plain\fs24  ceRxParity in Errors \b then\plain\fs24 
\par     ShowMessage('Paity error occured');
\par \b end\plain\fs24 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} Waiting for events}
{\up #}{\footnote\pard\plain{\up #} V8.XEM}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Waiting for events}
\b\fs28 Waiting for events
\par \pard \plain\fs24 When \uldb Events\plain\fs24 {\v 2ATT87P} property is not empty, a special thread is created for monitoring port events when application calls \uldb Open\plain\fs24 {\v SMQ_I0} method. This is possible only when you use TComPort component in an application (thread) which creates message loop. Most applications have message loop (GUI, NT services). However, if you want to use TComPort component in a console application, you have to set Events property to empty before calling Open method or your application will crash. To monitor events in console application, you have to use \uldb WaitForEvent\plain\fs24 {\v 48JZY8} method.
\par \pard \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \b\fs20 var
\par \plain\fs20   ComPort: TComPort;
\par   Events: TComEvents;
\par \fs16 
\par \b\fs20 begin
\par \plain\fs24   ComPort := TComPort.Create(\b nil\plain\fs24 );
\par   \b try
\par \plain\fs24     ComPort.Events := [];  \i\cf1 // do not create monitoring thread\plain\fs24 
\par     ComPort.Open;  \i\cf1 // open port\plain\fs24 
\par     Events := [evCTS, evDSR, evRLSD];  \i\cf1 // define events to wait for\plain\fs24 
\par     ComPort.WaitForEvents(Events, \b nil\plain\fs24 , WaitInfinite);  \i\cf1 // wait until at least one event happens\plain\fs24 
\par     \b if\plain\fs24  evCTS \b in\plain\fs24  Events \b then\plain\fs24 
\par \pard       WriteLn('CTS Changed');  \i\cf1 // CTS signal changed state\plain\fs24 
\par     ComPort.Close;  \i\cf1 // close port\plain\fs24 
\par   \b finally
\par \plain\fs24     ComPort.Free;
\par   \b end\plain\fs24 ;
\par \b end\plain\fs24 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} About packets}
{\up #}{\footnote\pard\plain{\up #} 3MR1YW0}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} About packets}
\b\fs28 About packets
\par \pard \plain\fs24 When application is connected to some sort of serial device like data loggers which constantly send data to PC, data is usually sent in packets. Packet is a string of charachters, usually of constant size, with some start and/or stop charachters. Application can parse incoming data inside \uldb OnRxChar\plain\fs24 {\v .1WU8Y} event handler, but its much easier to use \uldb TComDataPacket\plain\fs24 {\v 82GU66} component, which does parsing process automatically.
\par \fs16 
\par \fs24 One \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} can have more than one TComDataPacket components linked, so application can easily recieve packets of different sizes and forms.
\par \pard When packet is formed \uldb OnPacket\plain\fs24 {\v 1XOO74L} event is triggered with packet string as parameter. Any data that is discarded during the process of packet forming goes through \uldb OnDiscard\plain\fs24 {\v IBN5GA} event.
\par \fs16 
\par \fs24 If TComDataPacket component is linked to TCustomComPort component, OnRxChar event of TCustomComPort is not triggered, so application has to use \uldb OnRxBuf\plain\fs24 {\v 1HGAF55} event handler if it also needs unparsed incoming data.
\par \page
{\up $}{\footnote\pard\plain{\up $} Start and stop conditions}
{\up #}{\footnote\pard\plain{\up #} 42HL2BA}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Start and stop conditions}
\b\fs28 Start and stop conditions
\par \pard \plain\fs24 Application sets up packet by setting start and stop conditions. This is accomplished by setting \uldb StartString\plain\fs24 {\v 022FNL}, \uldb StopString\plain\fs24 {\v 42YS_ZI} and \uldb Size\plain\fs24 {\v 1HM024} properties of \uldb TComDataPacket\plain\fs24 {\v 82GU66} component.
\par \fs16 
\par \fs24 If StartString property is not empty, packet starts when StartString string has arrived in input buffer. If StartString is empty, packet starts immidiately when any charachter arrives in input buffer.
\par \fs16 
\par \fs24 Stop condition is defined by StopString and Size property. If Size is 0, size stop condition is ignored. If Size is larger than 0, packet is ended when packet size reaches Size charachters. If StopString is not empty, packet stops when StopString string arrives in input buffer. If Size is larger than 0 and StopString is not empty, packet is ended when size of packet reaches Size charachters or StopString string arrives in input buffer. If Size is 0 and StopString is 0 then packet is not defined and \uldb OnPacket\plain\fs24 {\v 1XOO74L} has the same effect as \uldb OnRxBuf\plain\fs24 {\v 1HGAF55} event handler.
\par \pard \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \fs24 Some PBX device sends data to PC in packets, starting with STX (start-of-text) charachter and ending with ETX (end-of-text) charachter. Before opening serial port, application should set up start and stop condition like this: 
\par \fs16 
\par \b\fs24 begin
\par \plain\fs24   \i\cf1 // set start and stop condition for packet
\par \plain\fs24   ComDataPacket1.StartString := #2;
\par   ComDataPacket1.StopString := #3;
\par   \cf1 // now open the port
\par \plain\fs24   ComPort1.Open;
\par \b end\plain\fs24 ;
\par \fs16 
\par \b\fs20 Note
\par \pard \plain\fs24 ComDataPacket1 has to be linked to ComPort1 component.
\par \page
{\up $}{\footnote\pard\plain{\up $} Custom packets}
{\up #}{\footnote\pard\plain{\up #} LQNTKJ}
\pard\brdrb\brdrs {\up K}{\footnote\pard\plain{\up K} Custom packets}
\b\fs28 Custom packets
\par \pard \plain\fs24 Some packets have specific form and sometimes application can't use standard start and stop conditions. To form a custom packet, application has write \uldb OnCustomStart\plain\fs24 {\v NC61WH} and/or \uldb OnCustomStop\plain\fs24 {\v 2HQA_KW} event handler of \uldb TComDataPacket\plain\fs24 {\v 82GU66} component. If OnCustomStart event handler is assigned, \uldb StartString\plain\fs24 {\v 022FNL} start condition is ignored and it is defined inside event handler. Simillary, if OnCustomStop event handler is assigned, \uldb StopString\plain\fs24 {\v 42YS_ZI} and \uldb Size\plain\fs24 {\v 1HM024} stop conditions are ignored and defined in OnCustomStop event handler.
\par \pard \fs16 
\par 
\par \ul\fs20 Example
\par \plain\fs16 
\par \fs20 Data from serial device is sent to PC in the following format: #packet_size#packet_data
\par where packet_size is size of packet including header and packet_data is raw data.
\par \fs16 
\par \b\fs24 var
\par \plain\fs20   CurrentPacketSize: Integer;
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ComDataPacket1CustomStart(Sender: TObject; \b const\plain\fs24  Str: \b string\plain\fs24 ; \b var\plain\fs24  Pos: Integer);
\par \b var
\par \plain\fs24   P1, P2: Integer;
\par \b begin
\par \plain\fs24   Pos := 0; \i\cf1 // no start position yet\plain\fs24 
\par \fs20   P1 := System.Pos('#', Str);
\par \pard \fs24   \b if\plain\fs24  P1 = 0 \b then\plain\fs24 
\par     Exit; \i\cf1 // no start charachter found\plain\fs24 
\par   P2 := System.Pos('#', Copy(Str, P1 + 1, Length(Str) \'96 P1)); \cf1 // second # charachter\plain\fs24 
\par \fs20   \b if\plain\fs20  P2 = 0 \b then\plain\fs20 
\par \fs24     Exit;  \i\cf1 // no second start charachter found\plain\fs24 
\par   P2 := P2 + P1;
\par   Pos := P1; \i\cf1 // start position of packet defined at first # charachter\plain\fs24 
\par   \b try
\par \plain\fs24     \i\cf1 // determine packet size
\par \plain\fs20    CurrentPacketSize := StrToInt(Copy(Str, P1 + 1, P2 \'96 P1 - 1));
\par \pard \fs24   \b except
\par \plain\fs20    CurrentPacketSize := P2 \'96 P1 + 1; \i\cf1 // packet size is corrupted, cut only #\'85# part\plain\fs20 
\par \fs24   \b end\plain\fs24 ;
\par \b end\plain\fs24 ;
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ComDataPacket1CustomStop(Sender: TObject; \b const\plain\fs24  Str: string; \b var\plain\fs24  Pos: Integer);
\par \b begin
\par \plain\fs24   \b if\plain\fs24  CurrentPacketSize <= Length(Str) \b then
\par \plain\fs24     Pos := CurrentPacketSize; \i\cf1 // set stop position\plain\fs24 
\par \b end\plain\fs24 ;
\par \page
{\up $}{\footnote\pard\plain{\up $} TComPort}
{\up #}{\footnote\pard\plain{\up #} 1OE68K5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComPort_Object,TComPort}
{\up K}{\footnote\pard\plain{\up K} TComPort}
\b\fs28\cf1 \{bml bm0.BMP\} TComPort\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 61G0_Q}       \uldb Properties\plain\fs20 {\v AXJVH0>props}       \uldb Methods\plain\fs20 {\v 2IS64WD>props}       \uldb Events\plain\fs20 {\v 14AR66>props}
\par \pard TComPort is a serial communication component.\b 
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPort
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use TComPort component to easily communicate with external devices on RS232 connection, such as modems, bar code readers, PBX and so on. TCustomComPort introduces several properties for detailed setting of serial port, numerous methods to write and read from port and events for monitoring port. Write and read operations can be performed synchronously or asynchronously.
\par \page
{\up #}{\footnote\pard\plain{\up #} 191_ZXL}
\pard \fs16 
\par \b\fs20 Scope
\par \plain\fs20 \{bmc bm1.BMP\} Published
\par \{bmc bm2.BMP\} Protected
\par \fs16 
\par \b\fs20 Accessibility
\par \plain\fs20 \{bmc bm3.BMP\} Read-only
\par \fs16 
\par \page
{\up #}{\footnote\pard\plain{\up #} 61G0_Q}
\pard \b\fs20 Hierarchy\plain\fs20 
\par \fs16 
\par \fs20 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TCustomComPort
\par        |
\par TComPort
\par \page
{\up #}{\footnote\pard\plain{\up #} AXJVH0}
\pard\keepn \b\fs24\cf1 TComPort properties\plain\fs24 
\par \uldb \fs20 TComPort\plain\fs20 {\v 1OE68K5>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 Derived from TCustomComPort
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb BaudRate\plain\fs20 {\v B.1Q.Y>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Buffer\plain\fs20 {\v _8118J>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Connected\plain\fs20 {\v 3JRPNVU>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb CustomBaudRate\plain\fs20 {\v 7NY549>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb DataBits\plain\fs20 {\v 3EUL0ZV>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb DiscardNull\plain\fs20 {\v 14IXF6B>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb EventChar\plain\fs20 {\v HZ4SCA>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Events\plain\fs20 {\v 2ATT87P>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb EventThreadPriority\plain\fs20 {\v 21YW5Q8>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb FlowControl\plain\fs20 {\v 8XPK4O>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb Handle\plain\fs20 {\v 14XDYVM>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Parity\plain\fs20 {\v JO_4GQ>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Port\plain\fs20 {\v 1EW3.BP>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb StopBits\plain\fs20 {\v 8_TM0E>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb StoredProps\plain\fs20 {\v 117OFJL>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb SyncMethod\plain\fs20 {\v 5Q.O_T7>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Timeouts\plain\fs20 {\v 2WR7AUE>main}
\par \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb TriggersOnRxChar\plain\fs20 {\v 3YS4_IF>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 14AR66}
\pard\keepn \b\fs24\cf1 TComPort events\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TComPort\plain\fs20 {\v 1OE68K5>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs20 Derived from TCustomComPort
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnAfterClose\plain\fs20 {\v JLKPS4>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnAfterOpen\plain\fs20 {\v 3.XSO_P>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnBeforeClose\plain\fs20 {\v 0LG1MF>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnBeforeOpen\plain\fs20 {\v 5MLTNW>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnBreak\plain\fs20 {\v 8ONIHE>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnCTSChange\plain\fs20 {\v 1AQGUQ8>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnDSRChange\plain\fs20 {\v D9C427>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnError\plain\fs20 {\v 8RNVVL>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnRing\plain\fs20 {\v 1.0I3XO>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnRLSDChange\plain\fs20 {\v 603U0G>main}
\par \pard \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnRx80Full\plain\fs20 {\v 1.GB4HU>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnRxChar\plain\fs20 {\v .1WU8Y>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnRxBuf\plain\fs20 {\v 1HGAF55>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnRxFlag\plain\fs20 {\v .1ZY8N>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnTxEmpty\plain\fs20 {\v CLAQ6F>main}
\par 
\par \page
{\up #}{\footnote\pard\plain{\up #} 2IS64WD}
\pard\keepn \b\fs24\cf1 TComPort methods\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TComPort\plain\fs20 {\v 1OE68K5>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs24 Derived from TCustomComPort
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb AbortAllAsync\plain\fs20 {\v 1WZGA>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb BeginUpdate\plain\fs20 {\v B_D7I8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ClearBuffer\plain\fs20 {\v 1.9TBHL>main}\b\fs24 
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Close\plain\fs20 {\v 54QM.VP>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 1MGGVK2>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v GREO66>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb EndUpdate\plain\fs20 {\v 9.E.CP>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb InputCount\plain\fs20 {\v 36QF7A>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb IsAsyncCompleted\plain\fs20 {\v I_WOPB>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb LastErrors\plain\fs20 {\v 1KVBTD>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb LoadSettings\plain\fs20 {\v G130FW>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Open\plain\fs20 {\v SMQ_I0>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OutputCount\plain\fs20 {\v 328WW5E>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Read\plain\fs20 {\v 6DH2XK>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ReadAsync\plain\fs20 {\v 33R40Q0>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ReadStr\plain\fs20 {\v 2_E4XD.>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ReadStrAsync\plain\fs20 {\v YY_0P1>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetBreak\plain\fs20 {\v 1J7W_T0>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetDTR\plain\fs20 {\v 2OD7Y7O>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetRTS\plain\fs20 {\v 2OD8.7P>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetXonXoff\plain\fs20 {\v FWQ6FI>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ShowSetupDialog\plain\fs20 {\v 17MJC_D>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Signals\plain\fs20 {\v GXHHC>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb StateFlags\plain\fs20 {\v BZP_YG>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb StoreSettings\plain\fs20 {\v 6YO5N.>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb TransmitChar\plain\fs20 {\v 1_UCTVO>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WaitForAsync\plain\fs20 {\v 44HCXR>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WaitForEvent\plain\fs20 {\v 48JZY8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Write\plain\fs20 {\v 11Y69LF>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteAsync\plain\fs20 {\v 44QH0K0>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteStr\plain\fs20 {\v UMEGVS>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteStrAsync\plain\fs20 {\v JL0ZGV>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort}
{\up #}{\footnote\pard\plain{\up #} 1W4XK_N}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_Object,TCustomComPort}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort}
\b\fs28\cf1 TCustomComPort\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 8SCYSI}       \uldb Properties\plain\fs20 {\v 8Z8OVC>props}       \uldb Methods\plain\fs20 {\v 1OR._H3>props}       \uldb Events\plain\fs20 {\v 10WBYEO>props}
\par \pard TCustomComPort is a base class for a serial component\b .
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPort
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 TCustomComPort is a base class for TComPort and other user defined serial components. Do not create an instance of TCustomComPort, but rather use TCustomComPort descendand such as \uldb TComPort\plain\fs20 {\v 1OE68K5}.
\par \page
{\up #}{\footnote\pard\plain{\up #} 8SCYSI}
\pard \b Hierarchy\plain\fs20 
\par \fs16 
\par \fs20 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TCustomComPort
\par \page
{\up #}{\footnote\pard\plain{\up #} 8Z8OVC}
\pard\keepn \b\fs24\cf1 TCustomComPort properties\plain\fs24 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TCustomComPort
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb BaudRate\plain\fs20 {\v B.1Q.Y>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Buffer\plain\fs20 {\v _8118J>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Connected\plain\fs20 {\v 3JRPNVU>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb CustomBaudRate\plain\fs20 {\v 7NY549>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb DataBits\plain\fs20 {\v 3EUL0ZV>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb DiscardNull\plain\fs20 {\v 14IXF6B>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb EventChar\plain\fs20 {\v HZ4SCA>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Events\plain\fs20 {\v 2ATT87P>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb EventThreadPriority\plain\fs20 {\v 21YW5Q8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb FlowControl\plain\fs20 {\v 8XPK4O>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb Handle\plain\fs20 {\v 14XDYVM>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Parity\plain\fs20 {\v JO_4GQ>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Port\plain\fs20 {\v 1EW3.BP>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb StopBits\plain\fs20 {\v 8_TM0E>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb StoredProps\plain\fs20 {\v 117OFJL>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SyncMethod\plain\fs20 {\v 5Q.O_T7>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Timeouts\plain\fs20 {\v 2WR7AUE>main}
\par \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb TriggersOnRxChar\plain\fs20 {\v 3YS4_IF>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 10WBYEO}
\pard\keepn \b\fs24\cf1 TCustomComPort events\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs20 In TCustomComPort
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnAfterClose\plain\fs20 {\v JLKPS4>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnAfterOpen\plain\fs20 {\v 3.XSO_P>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnBeforeClose\plain\fs20 {\v 0LG1MF>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnBeforeOpen\plain\fs20 {\v 5MLTNW>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnBreak\plain\fs20 {\v 8ONIHE>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnCTSChange\plain\fs20 {\v 1AQGUQ8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnDSRChange\plain\fs20 {\v D9C427>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnError\plain\fs20 {\v 8RNVVL>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnRing\plain\fs20 {\v 1.0I3XO>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnRLSDChange\plain\fs20 {\v 603U0G>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnRx80Full\plain\fs20 {\v 1.GB4HU>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnRxChar\plain\fs20 {\v .1WU8Y>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnRxBuf\plain\fs20 {\v 1HGAF55>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnRxFlag\plain\fs20 {\v .1ZY8N>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnTxEmpty\plain\fs20 {\v CLAQ6F>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 1OR._H3}
\pard\keepn \b\fs24\cf1 TCustomComPort methods\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs24 In TCustomComPort
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb AbortAllAsync\plain\fs20 {\v 1WZGA>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb ApplyBuffer\plain\fs20 {\v AU_VIM>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb ApplyDCB\plain\fs20 {\v 7_KA86>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb ApplyTimeouts\plain\fs20 {\v 2BHPKBZ>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb BeginUpdate\plain\fs20 {\v B_D7I8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ClearBuffer\plain\fs20 {\v 1.9TBHL>main}\b\fs24 
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Close\plain\fs20 {\v 54QM.VP>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 1MGGVK2>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb CreateHandle\plain\fs20 {\v HVRNGN>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v GREO66>main}
\par \pard \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DestroyHandle\plain\fs20 {\v 4OJZ46>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoAfterClose\plain\fs20 {\v 7XRS_74>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoAfterOpen\plain\fs20 {\v 38HY60>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoBeforeClose\plain\fs20 {\v 5NN_DU>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoBeforeOpen\plain\fs20 {\v LM2EK8>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoBreak\plain\fs20 {\v QACARS>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoCTSChange\plain\fs20 {\v 9M639R>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoDSRChange\plain\fs20 {\v 2M8B09K>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoError\plain\fs20 {\v QDCO5Z>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoRing\plain\fs20 {\v 1NDU3E4>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoRLSDChange\plain\fs20 {\v 8FJC>main}
\par \pard \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoRx80Full\plain\fs20 {\v 16IROTF>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoRxChar\plain\fs20 {\v 179ZDEX>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoRxFlag\plain\fs20 {\v 1702HEM>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoTxEmpty\plain\fs20 {\v IKALMM>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb EndUpdate\plain\fs20 {\v 9.E.CP>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb InputCount\plain\fs20 {\v 36QF7A>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb IsAsyncCompleted\plain\fs20 {\v I_WOPB>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb LastErrors\plain\fs20 {\v 1KVBTD>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb LoadIniFile\plain\fs20 {\v 01ETD3>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb LoadSettings\plain\fs20 {\v G130FW>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb LoadRegistry\plain\fs20 {\v NI6NHU>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Open\plain\fs20 {\v SMQ_I0>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OutputCount\plain\fs20 {\v 328WW5E>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Read\plain\fs20 {\v 6DH2XK>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ReadAsync\plain\fs20 {\v 33R40Q0>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ReadStr\plain\fs20 {\v 2_E4XD.>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ReadStrAsync\plain\fs20 {\v YY_0P1>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetBreak\plain\fs20 {\v 1J7W_T0>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetDTR\plain\fs20 {\v 2OD7Y7O>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetRTS\plain\fs20 {\v 2OD8.7P>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb SetupComPort\plain\fs20 {\v 11YY14Y>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SetXonXoff\plain\fs20 {\v FWQ6FI>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ShowSetupDialog\plain\fs20 {\v 17MJC_D>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Signals\plain\fs20 {\v GXHHC>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb StateFlags\plain\fs20 {\v BZP_YG>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb StoreIniFile\plain\fs20 {\v V8F8W3>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb StoreSettings\plain\fs20 {\v 6YO5N.>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb StoreRegistry\plain\fs20 {\v 3OJ8GD4>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb TransmitChar\plain\fs20 {\v 1_UCTVO>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WaitForAsync\plain\fs20 {\v 44HCXR>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WaitForEvent\plain\fs20 {\v 48JZY8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Write\plain\fs20 {\v 11Y69LF>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteAsync\plain\fs20 {\v 44QH0K0>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteStr\plain\fs20 {\v UMEGVS>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteStrAsync\plain\fs20 {\v JL0ZGV>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Handle}
{\up #}{\footnote\pard\plain{\up #} 14XDYVM}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Handle;Handle_Property;TCustomComPort_Handle}
{\up K}{\footnote\pard\plain{\up K} Handle;Handle,TCustomComPort;TCustomComPort,Handle}
\b\fs28\cf1 TCustomComPort.Handle\plain\fs28 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Provides access to file handle of serial port.
\par \fs16 
\par \b\fs24 property\plain\fs24  Handle: THandle
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Use Handle property when calling Win32 API functions for serial communication.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Handle property is valid only when Connected property is True.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.BaudRate}
{\up #}{\footnote\pard\plain{\up #} B.1Q.Y}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} BaudRate;BaudRate_Property;TCustomComPort_BaudRate}
{\up K}{\footnote\pard\plain{\up K} BaudRate;BaudRate,TCustomComPort;TCustomComPort,BaudRate}
\b\fs28\cf1 TCustomComPort.BaudRate
\par \plain\fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets charachter transmission speed.
\par \fs16 
\par \b\fs24 type\plain\fs24  TBaudRate = (brCustom, br110, br300, br600, br1200, br2400, br4800, br9600,br14400, br19200, br38400, br56000, br57600, br115200);
\par \b property \plain\fs24 BaudRate: TBaudRate;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 BaudRate property represents the speed at which charchters are sent or received via RS232 conection. Both sides of connection should have the same BaudRate. If BaudRate has a value of brCustom, \uldb CustomBaudRate\plain\fs24 {\v 7NY549} property is used to set baud rate.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.CustomBaudRate}
{\up #}{\footnote\pard\plain{\up #} 7NY549}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} CustomBaudRate;CustomBaudRate_Property;TCustomComPort_CustomBaudRate}
{\up K}{\footnote\pard\plain{\up K} CustomBaudRate;CustomBaudRate,TCustomComPort;TCustomComPort,CustomBaudRate}
\b\fs28\cf1 TCustomComPort.CustomBaudRate
\par \plain\fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets custom charachter transmission speed.
\par \fs16 
\par \b\fs24 property \plain\fs24 CustomBaudRate: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use CustomBaudRate property to set custom baud rate for charachter transmission. Ff \uldb BaudRate\plain\fs24 {\v B.1Q.Y} property is not set to brCustom, CustomBaudRate property has no effect.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DiscardNull}
{\up #}{\footnote\pard\plain{\up #} 14IXF6B}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DiscardNull;DiscardNull_Property;TCustomComPort_DiscardNull}
{\up K}{\footnote\pard\plain{\up K} DiscardNull;DiscardNull,TCustomComPort;TCustomComPort,DiscardNull}
\b\fs28\cf1 TCustomComPort.DiscardNull\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Enables removal of null charachters.
\par \fs16 
\par \b\fs24 property\plain\fs24  DiscardNull: Boolean
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Specifies whether null bytes are discarded. If this property is True, null bytes are discarded when received.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.EventChar}
{\up #}{\footnote\pard\plain{\up #} HZ4SCA}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} EventChar;EventChar_Property;TCustomComPort_EventChar}
{\up K}{\footnote\pard\plain{\up K} EventChar;EventChar,TCustomComPort;TCustomComPort,EventChar}
\b\fs28\cf1 TCustomComPort.EventChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Specifies the ASCII value of the charachter to signal an event.
\par \fs16 
\par \b\fs24 property\plain\fs24  EventChar: Char;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 When event charachter is received, both \uldb OnRxFlag\plain\fs24 {\v .1ZY8N} and \uldb OnRxChar\plain\fs24 {\v .1WU8Y} events are triggered.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.StopBits}
{\up #}{\footnote\pard\plain{\up #} 8_TM0E}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StopBits;StopBits_Property;TCustomComPort_StopBits}
{\up K}{\footnote\pard\plain{\up K} StopBits;StopBits,TCustomComPort;TCustomComPort,StopBits;TStopBits type}
\b\fs28\cf1 TCustomComPort.StopBits\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Specifies the number of stop bits to be used.
\par \fs16 
\par \b\fs24 type\plain\fs24  TStopBits = (sbOneStopBit, sbOne5StopBits, sbTwoStopBits);
\par \b property\plain\fs24  StopBits: TStopBits;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Sets the number of stop bits per charachter. StopBits can be set to one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 sbOneStopBit\tab \tab \tab 1 stop bit per byte
\par sbOne5StopBits\tab \tab 1.5 stop bits per byte
\par sbTwoStopBits\tab \tab \tab 2 stop bits per byte
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Use of 5 data bits with 2 stop bits is invalid combination, as is 6, 7 or 8 data bits with 1.5 stop bits.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Events}
{\up #}{\footnote\pard\plain{\up #} 2ATT87P}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Events;Events_Property;TCustomComPort_Events}
{\up K}{\footnote\pard\plain{\up K} Events;Events,TCustomComPort;TComEvent type;TComEvents type;TCustomComPort,Events}
\b\fs28\cf1 TCustomComPort.Events
\par \plain\fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Enables or disables event monitoring.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComEvent = (evRxChar, evTxEmpty, evRxFlag, evRing, evBreak, evCTS, evDSR, evError, evRLSD, evRx80Full);
\par \b type\plain\fs24  TComEvents = \b set of\plain\fs24  TComEvent;
\par \b property\plain\fs24  Events: TComEvents;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use events property to enable or disable monitoring for specific event. If there is at least one event set, a special thread is created that monitors events on serial port.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.EventThreadPriority}
{\up #}{\footnote\pard\plain{\up #} 21YW5Q8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} EventThreadPriority;EventThreadPriority_Property;TCustomComPort_EventThreadPriority}
{\up K}{\footnote\pard\plain{\up K} EventThreadPriority;EventThreadPriority,TCustomComPort;TCustomComPort,EventThreadPriority}
\b\fs28\cf1 TCustomComPort.EventThreadPriority
\par \plain\fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Set priority of event thread
\par \fs16 
\par \b\fs24 property\plain\fs24  EventThreadPriority: TThreadPriority;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set this property to change priority of event thread. It has to be set before call to Open method. The default value is tpNormal.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Connected}
{\up #}{\footnote\pard\plain{\up #} 3JRPNVU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Connected;Connected_Property;TCustomComPort_Connected}
{\up K}{\footnote\pard\plain{\up K} Connected;Connected,TCustomComPort;TCustomComPort,Connected}
\b\fs28\cf1 TCustomComPort.Connected\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Indicates whether or not a serial connection is active.
\par \fs16 
\par \b\fs24 property\plain\fs24  Connected: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set Connected to True to open serial port. Set Connected to False close connection to serial port. An application can check Connected to determine whether or not a serial port is open. If Connected is True, serial port is open, otherwise it is closed.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Setting Connected to True is the same as calling \uldb Open\plain\fs24 {\v SMQ_I0} method. Setting connected to False is the same as calling \uldb Close\plain\fs24 {\v 54QM.VP} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Timeouts}
{\up #}{\footnote\pard\plain{\up #} 2WR7AUE}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_Timeouts;Timeouts;Timeouts_Property}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,Timeouts;Timeouts;Timeouts,TCustomComPort}
\b\fs28\cf1 TCustomComPort.Timeouts\plain\b\fs24 
\par \plain\fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Specifies timeout values for transmission.
\par \fs16 
\par \b\fs24 property\plain\fs24  Timeouts: \uldb TComTimeouts\plain\fs24 {\v 1N1MC_O};
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Timeouts property to set interval and complete timeout values for read and write operations.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DataBits}
{\up #}{\footnote\pard\plain{\up #} 3EUL0ZV}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DataBits;DataBits_Property;TCustomComPort_DataBits}
{\up K}{\footnote\pard\plain{\up K} DataBits;DataBits,TCustomComPort;TCustomComPort,DataBits;TDataBits type}
\b\fs28\cf1 TCustomComPort.DataBits\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Specifies the number of bits in a byte.
\par \fs16 
\par \b\fs24 type\plain\fs24  TDataBits = (dbFive, dbSix, dbSeven, dbEight);
\par \b property\plain\fs24  DataBits: TDataBits;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Sets the number of bits in the bytes transmitted and received.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Use of 5 data bits with 2 stop bits is invalid combination, as is 6, 7 or 8 data bits with 1.5 stop bits.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Buffer}
{\up #}{\footnote\pard\plain{\up #} _8118J}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Buffer;Buffer_Property;TCustomComPort_Buffer}
{\up K}{\footnote\pard\plain{\up K} Buffer;Buffer,TCustomComPort;TCustomComPort,Buffer}
\b\fs28\cf1 TCustomComPort.Buffer\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Specifies the size of serial port buffer
\par \fs16 
\par \b\fs24 property\plain\fs24  Buffer: \uldb TComBuffer\plain\fs24 {\v 1ZPRRVU};
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Buffer property to set the size of input and output buffer of serial port.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Buffer sizes are only recommended to serial driver. The serial driver is free to use any other size.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.FlowControl}
{\up #}{\footnote\pard\plain{\up #} 8XPK4O}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} FlowControl;FlowControl_Property;TCustomComPort_Control}
{\up K}{\footnote\pard\plain{\up K} FlowControl;FlowControl,TCustomComPort;TCustomComPort,FlowControl}
\b\fs28\cf1 TCustomComPort.FlowControl\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets flow control type.
\par \fs16 
\par \b\fs24 property\plain\fs24  FlowControl: \uldb TComFlowControl\plain\fs24 {\v 1_L_I7P};
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use FlowControl property to set flow control type to hardware, software or none.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Parity}
{\up #}{\footnote\pard\plain{\up #} JO_4GQ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Parity;Parity_Property;TCustomComPort_Parity}
{\up K}{\footnote\pard\plain{\up K} Parity;Parity,TCustomComPort;TCustomComPort,Parity}
\b\fs28\cf1 TCustomComPort.Parity\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets parity settings.
\par \fs16 
\par \b\fs24 property\plain\fs24  Parity: \uldb TComParity\plain\fs24 {\v XUFW7.}
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Parity property to enable or disable parity checking, error replacement and parity type.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.SyncMethod}
{\up #}{\footnote\pard\plain{\up #} 5Q.O_T7}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SyncMethod;SyncMethod_Property;TCustomComPort_SyncMethod}
{\up K}{\footnote\pard\plain{\up K} SyncMethod;SyncMethod,TCustomComPort;TCustomComPort,SyncMethod;TSyncMethod type}
\b\fs28\cf1 TCustomComPort.SyncMethod\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets synchronization method for events.
\par \fs16 
\par \b\fs24 type\plain\fs24  TSyncMethod = (smThreadSync, smWindowSync, smNone);
\par \b property\plain\fs24  SyncMethod: TSyncMethod;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 SyncMethod defines in context of which thread the events will be called. SyncMethod can be one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 smThreadSync\tab \tab Events are called in context of main application thread.
\par smWindowSync\tab Events are called in context of thread that called Open method.
\par smNone\tab \tab Events are called in context of special monitoring thread
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 SyncMethod should usually be set to smThreadSync. Use smWindowSync in Windows NT service applications to define in which thread should events be called.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Port}
{\up #}{\footnote\pard\plain{\up #} 1EW3.BP}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Port;Port_Property;TCustomComPort_Port}
{\up K}{\footnote\pard\plain{\up K} Port;Port,TCustomComPort;TCustomComPort,Port;TPort type}
\b\fs28\cf1 TCustomComPort.Port\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets serial port number.
\par \fs16 
\par \b\fs24 type\plain\fs24  TPort = \b String\plain\fs24 ;
\par \b property\plain\fs24  Port: TPort;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Port property to set serial port number. Port values have the following syntax: 'COMportnumber' or 'portnumber'. If Port is changed during a session, old port is closed and new one is opened. Application can call \uldb EnumComPorts\plain\fs24 {\v 1IVFZWT} procedure to enumerate serial ports on local computer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.TriggersOnRxChar}
{\up #}{\footnote\pard\plain{\up #} 3YS4_IF}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_TriggersOnRxChar;TriggersOnRxChar;TriggersOnRxChar_Property}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,TriggersOnRxChar;TriggersOnRxChar;TriggersOnRxChar,TCustomComPort}
\b\fs28\cf1 TCustomComPort.TriggersOnRxChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Indicates event which is called when data arrives in input buffer.
\par \fs16 
\par \b\fs24 property\plain\fs24  TriggersOnRxChar: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use TriggersOnRxChar property to check at runtime which event is called when data arrives in input buffer. If TriggersOnRxChar is True, \uldb OnRxChar\plain\fs24 {\v .1WU8Y} event is called. If it returns False, \uldb OnRxBuf\plain\fs24 {\v 1HGAF55} event is called.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.StoredProps}
{\up #}{\footnote\pard\plain{\up #} 117OFJL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StoredProps;StoredProps_Property;TCustomComPort_StoredProps}
{\up K}{\footnote\pard\plain{\up K} StoredProps;StoredProps,TCustomComPort;TCustomComPort,StoredProps;TStoredProp type;TStoredProps type}
\b\fs28\cf1 TCustomComPort.StoredProps\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Defines properties to be stored or loaded.
\par \fs16 
\par \b\fs24 type\plain\fs24  TStoredProp = (spBasic, spFlowControl, spBuffer, spTimeouts, spParity, spOthers);
\par \b type\plain\fs24  TStoredProps = set of TStoredProp;
\par \fs16 
\par \b\fs24 property\plain\fs24  StoredProps: TStoredProps;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use StoreProps property to define which properties are stored or loaded when calling \uldb StoreSettings\plain\fs24 {\v 6YO5N.} or \uldb LoadSettings\plain\fs24 {\v G130FW}. StoredProps can have one or more of the following values:
\par 
\par \pard\brdrb\brdrs\tx355 \b TStoredProps\plain\fs24 \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 spBasic\tab \tab \tab PortNum, BaudRate, DataBits, StopBits,
\par \pard\li1415\fi705\tx355 Parity and FlowControl
\par \pard\tx355 spFlowControl\tab \tab Detailed flow control settings
\par spBuffer\tab \tab Input and ouput buffer size
\par spTimeouts\tab \tab Timeout values
\par spParity\tab \tab Detailed parity settings
\par spOthers\tab \tab EventChar and DiscardNull properties
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.AbortAllAsync}
{\up #}{\footnote\pard\plain{\up #} 1WZGA}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AbortAllAsync;AbortAllAsync_Method;TCustomComPort_AbortAllAsync}
{\up K}{\footnote\pard\plain{\up K} AbortAllAsync;AbortAllAsync,TCustomComPort;TCustomComPort,AbortAllAsync}
\b\fs28\cf1 TCustomComPort.AbortAllAsync\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Aborts all pending asynchronous operations.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  AbortAllAsync;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call AbortAllAsync method to cancel all pending asynchronous operations. If \uldb WaitForAsync\plain\fs24 {\v 44HCXR} method is called after AbortAllAsync, it raises \uldb EComPort\plain\fs24 {\v T2D5VU} exception with WinCode ERROR_OPERATION_ABORTED. 
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Application is still responsible to free Async pointer of all pending operations using \uldb DoneAsync\plain\fs24 {\v 2_5VP2K} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ApplyBuffer}
{\up #}{\footnote\pard\plain{\up #} AU_VIM}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ApplyBuffer;ApplyBuffer_Method;TCustomComPort_ApplyBuffer}
{\up K}{\footnote\pard\plain{\up K} ApplyBuffer;ApplyBuffer,TCustomComPort;TCustomComPort,ApplyBuffer}
\b\fs28\cf1 TCustomComPort.ApplyBuffer
\par \plain\fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sends buffer sizes to serial driver.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ApplyBuffer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 ApplyBuffer method sends buffer sizes from \uldb Buffer\plain\fs24 {\v _8118J} property to serial driver.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ApplyDCB}
{\up #}{\footnote\pard\plain{\up #} 7_KA86}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ApplyDCB;ApplyDCB_Method;TCustomComPort_ApplyDCB}
{\up K}{\footnote\pard\plain{\up K} ApplyDCB;ApplyDCB,TCustomComPort;TCustomComPort,ApplyDCB}
\b\fs28\cf1 TCustomComPort.ApplyDCB\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets serial port settings.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ApplyDCB;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 ApplyDCB method fills DCB record from TCustomComPort properties and sends it to serial driver.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ApplyTimeouts}
{\up #}{\footnote\pard\plain{\up #} 2BHPKBZ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ApplyTimeouts;ApplyTimeouts_Method;TCustomComPort_ApplyTimeouts}
{\up K}{\footnote\pard\plain{\up K} ApplyTimeouts;ApplyTimeouts,TCustomComPort;TCustomComPort,ApplyTimeouts}
\b\fs28\cf1 TCustomComPort.ApplyTimeouts\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets serial port timeouts.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ApplyTimeouts;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 ApplyTimeouts method fills COMMTIMEOUTS record from TCustomComPort properties and sends it to serial driver.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.BeginUpdate}
{\up #}{\footnote\pard\plain{\up #} B_D7I8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} BeginUpdate;BeginUpdate_Method;TCustomComPort_BeginUpdate}
{\up K}{\footnote\pard\plain{\up K} BeginUpdate;BeginUpdate,TCustomComPort;TCustomComPort,BeginUpdate}
\b\fs28\cf1 TCustomComPort.BeginUpdate\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Prevents port settings to be changed immidiatelly.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  BeginUpdate;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call BeginUpdate method to prevent port settings to be applied when any property is changed and Connected propertiy is set to True. After calling BeginUpdate, port settings are not applied until application calls \uldb EndUpdate\plain\fs24 {\v 9.E.CP} method. This is useful when application has to change more settings at a time to gain performance.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.EndUpdate}
{\up #}{\footnote\pard\plain{\up #} 9.E.CP}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} EndUpdate;EndUpdate_Method;TCustomComPort_EndUpdate}
{\up K}{\footnote\pard\plain{\up K} EndUpdate;EndUpdate,TCustomComPort;TCustomComPort,EndUpdate}
\b\fs28\cf1 TCustomComPort.EndUpdate\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Applies port settings.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  EndUpdate;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call EndUpdate method to apply changes made to properties after \uldb BeginUpdate\plain\fs24 {\v B_D7I8} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ClearBuffer}
{\up #}{\footnote\pard\plain{\up #} 1.9TBHL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ClearBuffer;ClearBuffer_Method;TCustomComPort_ClearBuffer}
{\up K}{\footnote\pard\plain{\up K} ClearBuffer;ClearBuffer,TCustomComPort;TCustomComPort,ClearBuffer}
\b\fs28\cf1 TCustomComPort.ClearBuffer\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Clears input and/or output buffer.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ClearBuffer(Input, Output: Boolean);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call ClearBuffer method to empty input and/or output buffer. If Input parameter is True, input buffer is cleared. If Output parameter is True, output buffer is cleared.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Close}
{\up #}{\footnote\pard\plain{\up #} 54QM.VP}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Close;Close_Method;TCustomComPort_Close}
{\up K}{\footnote\pard\plain{\up K} Close;Close,TCustomComPort;TCustomComPort,Close}
\b\fs28\cf1 TCustomComPort.Close\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Closes current session.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Close;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Close method closes connection to serial port. If serial port is already closed, Close method does nothing. When port is closed, application can't read or write to it.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Calling Close is the same as setting \uldb Connected\plain\fs24 {\v 3JRPNVU} property to False;
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Create}
{\up #}{\footnote\pard\plain{\up #} 1MGGVK2}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TCustomComPort_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TCustomComPort;TCustomComPort,Create}
\b\fs28\cf1 TCustomComPort.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Creates an instance of TCustomComPort class
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(AOwner: TComponent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Create to programatically create TCustomComPort object. ComPort components that are put on a form are automatically created.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.CreateHandle}
{\up #}{\footnote\pard\plain{\up #} HVRNGN}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} CreateHandle;CreateHandle_Method;TCustomComPort_CreateHandle}
{\up K}{\footnote\pard\plain{\up K} CreateHandle;CreateHandle,TCustomComPort;TCustomComPort,CreateHandle}
\b\fs28\cf1 TCustomComPort.CreateHandle\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Creates handle of serial port.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  TCustomComPort.CreateHandle; \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 CreateHandle is called by \uldb Open\plain\fs24 {\v SMQ_I0} method. This is where connection is really established. After call to CreateHandle, Handle property becomes valid.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Destroy}
{\up #}{\footnote\pard\plain{\up #} GREO66}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Destroy;Destroy_Method;TCustomComPort_Destroy}
{\up K}{\footnote\pard\plain{\up K} Destroy;Destroy,TCustomComPort;TCustomComPort,Destroy}
\b\fs28\cf1 TCustomComPort.Destroy\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Destroys TCustomComPort object.
\par \fs16 
\par \b\fs24 destructor\plain\fs24  Destroy; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TCustomComPort component is not already freed, and only then calls Destroy. If port is not closed, it is closed first.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DestroyHandle}
{\up #}{\footnote\pard\plain{\up #} 4OJZ46}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DestroyHandle;DestroyHandle_Method;TCustomComPort_DestroyHandle}
{\up K}{\footnote\pard\plain{\up K} DestroyHandle;DestroyHandle,TCustomComPort;TCustomComPort,DestroyHandle}
\b\fs28\cf1 TCustomComPort.DestroyHandle\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Destroys serial port handle.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DestroyHandle; \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 DestroyHandle is called inside \uldb Close\plain\fs24 {\v 54QM.VP} method. The connection to serial port is dropped and Handle property value becomes invalid.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoBreak}
{\up #}{\footnote\pard\plain{\up #} QACARS}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoBreak;DoBreak_Method;TCustomComPort_DoBreak}
{\up K}{\footnote\pard\plain{\up K} DoBreak;DoBreak,TCustomComPort;TCustomComPort,DoBreak}
\b\fs28\cf1 TCustomComPort.DoBreak\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnBreak event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoBreak; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When serial port detects break event, DoBreak method is called. DoBreak method calls \uldb OnBreak\plain\fs24 {\v 8ONIHE} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoBreak method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoAfterClose}
{\up #}{\footnote\pard\plain{\up #} 7XRS_74}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoAfterClose;DoAfterClose_Method;TCustomComPort_DoAfterClose}
{\up K}{\footnote\pard\plain{\up K} DoAfterClose;DoAfterClose,TCustomComPort;TCustomComPort,DoAfterClose}
\b\fs28\cf1 TCustomComPort.DoAfterClose\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnAfterClose event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoAfterClose; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par After serial port is successfully closed, DoAfterClose method is called. DoAfterClose method calls \uldb OnAfterClose\plain\fs24 {\v JLKPS4} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoAfterClose method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoAfterOpen}
{\up #}{\footnote\pard\plain{\up #} 38HY60}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoAfterOpen;DoAfterOpen_Method;TCustomComPort_DoAfterOpen}
{\up K}{\footnote\pard\plain{\up K} DoAfterOpen;DoAfterOpen,TCustomComPort;TCustomComPort,DoAfterOpen}
\b\fs28\cf1 TCustomComPort.DoAfterOpen\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnAfterOpen event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoAfterOpen; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par After serial port is successfully opened, DoAfterOpen method is called. DoAfterOpen method calls \uldb OnAfterOpen\plain\fs24 {\v 3.XSO_P} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoAfterOpen method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoBeforeClose}
{\up #}{\footnote\pard\plain{\up #} 5NN_DU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoBeforeClose;DoBeforeClose_Method;TCustomComPort_DoBeforeClose}
{\up K}{\footnote\pard\plain{\up K} DoBeforeClose;DoBeforeClose,TCustomComPort;TCustomComPort,DoBeforeClose}
\b\fs28\cf1 TCustomComPort.DoBeforeClose\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnBeforeClose event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoBeforeClose; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Before serial port is closed, DoBeforeClose method is called. DoBeforeClose method calls \uldb OnBeforeClose\plain\fs24 {\v 0LG1MF} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoBeforeClose method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoBeforeOpen}
{\up #}{\footnote\pard\plain{\up #} LM2EK8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoBeforeOpen;DoBeforeOpen_Method;TCustomComPort_DoBeforeOpen}
{\up K}{\footnote\pard\plain{\up K} DoBeforeOpen;DoBeforeOpen,TCustomComPort;TCustomComPort,DoBeforeOpen}
\b\fs28\cf1 TCustomComPort.DoBeforeOpen\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnBeforeOpen event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoBeforeOpen; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Before serial port is opened, DoBeforeOpen method is called. DoBeforeOpen method calls \uldb OnBeforeOpen\plain\fs24 {\v 5MLTNW} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoBeforeOpen method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoCTSChange}
{\up #}{\footnote\pard\plain{\up #} 9M639R}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoCTSChange;DoCTSChange_Method;TCustomComPort_DoCTSChange}
{\up K}{\footnote\pard\plain{\up K} DoCTSChange;DoCTSChange,TCustomComPort;TCustomComPort,DoCTSChange}
\b\fs28\cf1 TCustomComPort.DoCTSChange\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnCTSChange event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoCTSChange(OnOff: Boolean); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When CTS signal changes, DoCTSChange method is called. DoCTSChange method calls \uldb OnCTSChange\plain\fs24 {\v 1AQGUQ8} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoCTSChange method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoDSRChange}
{\up #}{\footnote\pard\plain{\up #} 2M8B09K}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoDSRChange;DoDSRChange_Method;TCustomComPort_DoDSRChange}
{\up K}{\footnote\pard\plain{\up K} DoDSRChange;DoDSRChange,TCustomComPort;TCustomComPort,DoDSRChange}
\b\fs28\cf1 TCustomComPort.DoDSRChange\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnDSRChange event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoDSRChange(OnOff: Boolean); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When DSR signal changes, DoDSRChange method is called. DoDSRChange method calls \uldb OnDSRChange\plain\fs24 {\v D9C427} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoDSRChange method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoRLSDChange}
{\up #}{\footnote\pard\plain{\up #} 8FJC}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoRLSDChange;DoRLSDChange_Method;TCustomComPort_DoRLSDChange}
{\up K}{\footnote\pard\plain{\up K} DoRLSDChange;DoRLSDChange,TCustomComPort;TCustomComPort,DoRLSDChange}
\b\fs28\cf1 TCustomComPort.DoRLSDChange\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnRLSDChange event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoRLSDChange(OnOff: Boolean); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When RLSD signal changes, DoRLSDChange method is called. DoRLSDChange method calls \uldb OnRLSDChange\plain\fs24 {\v 603U0G} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoRLSDChange method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoRxChar}
{\up #}{\footnote\pard\plain{\up #} 179ZDEX}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoRxChar;DoRxChar_Method;TCustomComPort_DoRxChar}
{\up K}{\footnote\pard\plain{\up K} DoRxChar;DoRxChar,TCustomComPort;TCustomComPort,DoRxChar}
\b\fs28\cf1 TCustomComPort.DoRxChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnRxChar event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoRxChar(Count: Integer); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When charachter(s) arrive in input buffer, DoRxChar method is called. DoRxChar method calls \uldb OnRxChar\plain\fs24 {\v .1WU8Y} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoRxChar method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoRxFlag}
{\up #}{\footnote\pard\plain{\up #} 1702HEM}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoRxFlag;DoRxFlag_Method;TCustomComPort_DoRxFlag}
{\up K}{\footnote\pard\plain{\up K} DoRxFlag;DoRxFlag,TCustomComPort;TCustomComPort,DoRxFlag}
\b\fs28\cf1 TCustomComPort.DoRxFlag\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnRxFlag event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoRxFlag; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When event charachter arrives in input buffer, DoRxFlag method is called. DoRxFlag method calls \uldb OnRxFlag\plain\fs24 {\v .1ZY8N} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoRxFlag method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoTxEmpty}
{\up #}{\footnote\pard\plain{\up #} IKALMM}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoTxEmpty;DoTxEmpty_Method;TCustomComPort_DoTxEmpty}
{\up K}{\footnote\pard\plain{\up K} DoTxEmpty;DoTxEmpty,TCustomComPort;TCustomComPort,DoTxEmpty}
\b\fs28\cf1 TCustomComPort.DoTxEmpty\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnTxEmpty event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoTxEmpty; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When all charachter are transmitted from ouput buffer, DoTxEmpty method is called. DoTxEmpty method calls \uldb OnTxEmpty\plain\fs24 {\v CLAQ6F} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoTxEmpty method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoRing}
{\up #}{\footnote\pard\plain{\up #} 1NDU3E4}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoRing;DoRing_Method;TCustomComPort_DoRing}
{\up K}{\footnote\pard\plain{\up K} DoRing;DoRing,TCustomComPort;TCustomComPort,DoRing}
\b\fs28\cf1 TCustomComPort.DoRing\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnRing event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoRing; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When ring indicator is detected, DoRing method is called. DoRing method calls \uldb OnRing\plain\fs24 {\v 1.0I3XO} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoRing method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoError}
{\up #}{\footnote\pard\plain{\up #} QDCO5Z}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoError;DoError_Method;TCustomComPort_DoError}
{\up K}{\footnote\pard\plain{\up K} DoError;DoError,TCustomComPort;TCustomComPort,DoError}
\b\fs28\cf1 TCustomComPort.DoError\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnError event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoError(Errors: TComErrors); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When all charachter are transmitted from ouput buffer, DoError method is called. DoError method calls \uldb OnError\plain\fs24 {\v 8RNVVL} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoError method directly, since it is called by TCustomComPort automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.DoRx80Full}
{\up #}{\footnote\pard\plain{\up #} 16IROTF}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoRx80Full;DoRx80Full_Method;TCustomComPort_DoRx80Full}
{\up K}{\footnote\pard\plain{\up K} DoRx80Full;DoRx80Full,TCustomComPort;TCustomComPort,DoRx80Full}
\b\fs28\cf1 TCustomComPort.DoRx80Full\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnRx80Full event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoRx80Full; \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When all charachter are transmitted from ouput buffer, DoRx80Full method is called. DoRx80Full method calls \uldb OnRx80Full\plain\fs24 {\v 1.GB4HU} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoRx80Full method directly, since it is called by TCustomComPort automatically.
\par 
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.InputCount}
{\up #}{\footnote\pard\plain{\up #} 36QF7A}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} InputCount;InputCount_Method;TCustomComPort_InputCount}
{\up K}{\footnote\pard\plain{\up K} InputCount;InputCount,TCustomComPort;TCustomComPort,InputCount}
\b\fs28\cf1 TCustomComPort.InputCount\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Returns the number of bytes in input buffer.
\par \fs16 
\par \b\fs24 function\plain\fs24  InputCount: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call InputCount function to get the number of bytes in input buffer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OuputCount}
{\up #}{\footnote\pard\plain{\up #} 328WW5E}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OuputCount_Method;OutputCount;TCustomComPort_OuputCount}
{\up K}{\footnote\pard\plain{\up K} OuputCount;OuputCount,TCustomComPort;TCustomComPort,OuputCount}
\b\fs28\cf1 TCustomComPort.OutputCount\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Returns the number of bytes in output buffer.
\par \fs16 
\par \b\fs24 function\plain\fs24  OutputCount: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call OutputCount function to get the number of bytes in output buffer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.IsAsyncCompleted}
{\up #}{\footnote\pard\plain{\up #} I_WOPB}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} IsAsyncCompleted;IsAsyncCompleted_Method;TCustomComPort_IsAsyncCompleted}
{\up K}{\footnote\pard\plain{\up K} IsAsyncCompleted;IsAsyncCompleted,TCustomComPort;TCustomComPort,IsAsyncCompleted}
\b\fs28\cf1 TCustomComPort.IsAsyncCompleted\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Indicates whether asynchronous operation is completed.
\par \fs16 
\par \b\fs24 function\plain\fs24  IsAsyncCompleted(AsyncPtr: PAsync): Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call IsAsyncCompleted to get asynchronous operation state. If the result is True, asynchronous operation is completed. If the result is False, operation is still in progress.
\par AsyncPtr parameter is variable initialized by \uldb InitAsync\plain\fs24 {\v PIWD4U} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.LastErrors}
{\up #}{\footnote\pard\plain{\up #} 1KVBTD}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} LastErrors;LastErrors_Method;TCustomComPort_LastErrors}
{\up K}{\footnote\pard\plain{\up K} LastErrors;LastErrors,TCustomComPort;TCustomComPort,LastErrors}
\b\fs28\cf1 TCustomComPort.LastErrors\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Returns last occured errors on port.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComError = (ceFrame, ceRxParity, ceOverrun, ceBreak, ceIO, ceMode, ceRxOver, ceTxFull);
\par TComErrors = \b set of\plain\fs24  TComError;
\par \b function\plain\fs24  LastErrors: TComErrors;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 LastErrors function returns a set of errors that happened after last call to LastErrors. The following errors can occur on serial port:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Error\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 ceFrame\tab \tab The hardware detected a framing error.
\par ceRxParity\tab \tab The hardware detected a parity error.
\par ceOverrun\tab \tab A charachter buffer overrun has occured.
\par \pard\li1415\fi705\tx355 The next charachter is lost.
\par \pard\tx355 ceBreak\tab \tab The hardware detected a break condition.
\par ceIO\tab \tab \tab An I/O error occured during communication
\par \pard\fi705\tx355 \tab \tab \tab with the device.
\par \pard\tx355 ceMode\tab \tab The requested mode is not supported.
\par ceRxOver\tab \tab An input buffer overflow has occured.
\par ceTxFull\tab \tab The output buffer is full
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.LoadSettings}
{\up #}{\footnote\pard\plain{\up #} G130FW}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} LoadSettings;LoadSettings_Method;TCustomComPort_LoadSettings}
{\up K}{\footnote\pard\plain{\up K} LoadSettings;LoadSettings,TCustomComPort;TCustomComPort,LoadSettings;TStoreType type}
\b\fs28\cf1 TCustomComPort.LoadSettings\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Loads TCustomComPort settings from registry or file.
\par \fs16 
\par \b\fs24 type\plain\fs24  TStoreType = (stRegistry, stIniFile);\fs16 
\par \b\fs24 procedure\plain\fs24  LoadSettings(StoreType: TStoreType; LoadFrom: \b String\plain\fs24 );
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 LoadSettings method loads stored TCustomComPort property values either from a file or registry. Which properties are loaded depends on \uldb StoredProps\plain\fs24 {\v 117OFJL} property. StoreType parameter can have one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 StoreType\plain\fs24 \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 stRegistry\tab \tab LoadFrom parameter is a registry key.
\par stIniFile\tab \tab \tab LoadFrom parameter is a file name.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.StoreSettings}
{\up #}{\footnote\pard\plain{\up #} 6YO5N.}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StoreSettings;StoreSettings_Method;TCustomComPort_StoreSettings}
{\up K}{\footnote\pard\plain{\up K} StoreSettings;StoreSettings,TCustomComPort;TCustomComPort,StoreSettings}
\b\fs28\cf1 TCustomComPort.StoreSettings\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Stores TCustomComPort settings to registry or file.
\par \fs16 
\par \b\fs24 type\plain\fs24  TStoreType = (stRegistry, stIniFile);\fs16 
\par \b\fs24 procedure\plain\fs24  StoreSettings(StoreType: TStoreType; StoreTo: \b String\plain\fs24 );
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 StoreSettings method stores TCustomComPort property values either in a file or registry. Which properties are stored depends on \uldb StoredProps\plain\fs24 {\v 117OFJL} property. StoreType parameter can have one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 StoreType\plain\fs24 \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 stRegistry\tab \tab StoreTo parameter is a registry key.
\par stIniFile\tab \tab \tab StoreTo parameter is a file name.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.StoreRegistry}
{\up #}{\footnote\pard\plain{\up #} 3OJ8GD4}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StoreRegistry;StoreRegistry_Method;TCustomComPort_StoreRegistry}
{\up K}{\footnote\pard\plain{\up K} StoreRegistry;StoreRegistry,TCustomComPort;TCustomComPort,StoreRegistry}
\b\fs28\cf1 TCustomComPort.StoreRegistry\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Stores TCustomComPort settings to registry.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  StoreRegistry(Reg: TRegistry); \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 StoreRegistry method stores most of TCustomComPort properties that deal with serial port settings to registry. Descendands can override this method to store additional properties.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call StoreRegistry directly. The method is called inside \uldb StoreSettings\plain\fs24 {\v 6YO5N.} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.StoreIniFile}
{\up #}{\footnote\pard\plain{\up #} V8F8W3}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StoreIniFile;StoreIniFile_Method;TCustomComPort_StoreIniFile}
{\up K}{\footnote\pard\plain{\up K} StoreIniFile;StoreIniFile,TCustomComPort;TCustomComPort,StoreIniFile}
\b\fs28\cf1 TCustomComPort.StoreIniFile\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Stores TCustomComPort settings to configuration file.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  StoreIniFile(IniFile: TIniFile); \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 StoreIniFile method stores most of TCustomComPort properties that deal with serial port settings to configuration file. Descendands can override this method to store additional properties.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call StoreIniFile directly. The method is called inside \uldb StoreSettings\plain\fs24 {\v 6YO5N.} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.LoadRegistry}
{\up #}{\footnote\pard\plain{\up #} NI6NHU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} LoadRegistry;LoadRegistry_Method;TCustomComPort_LoadRegistry}
{\up K}{\footnote\pard\plain{\up K} LoadRegistry;LoadRegistry,TCustomComPort;TCustomComPort,LoadRegistry}
\b\fs28\cf1 TCustomComPort.LoadRegistry\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Loads TCustomComPort settings from registry.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  LoadRegistry(Reg: TRegistry); \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 LoadRegistry method loads most of TCustomComPort properties that deal with serial port settings from registry. Descendands can override this method to load additional properties.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call LoadRegistry method directly. The method is called inside \uldb LoadSettings\plain\fs24 {\v G130FW} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.LoadIniFile}
{\up #}{\footnote\pard\plain{\up #} 01ETD3}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} LoadIniFile;LoadIniFile_Method;TCustomComPort_LoadIniFile}
{\up K}{\footnote\pard\plain{\up K} LoadIniFile;LoadIniFile,TCustomComPort;TCustomComPort,LoadIniFile}
\b\fs28\cf1 TCustomComPort.StoreIniFile\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Loads TCustomComPort settings from configuration file.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  LoadIniFile(IniFile: TIniFile); \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 LoadIniFile method loads most of TCustomComPort properties that deal with serial port settings from configuration file. Descendands can override this method to load additional properties.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call LoadIniFile directly. The method is called inside \uldb LoadSettings\plain\fs24 {\v G130FW} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Signals}
{\up #}{\footnote\pard\plain{\up #} GXHHC}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Signals;Signals_Method;TCustomComPort_Signals}
{\up K}{\footnote\pard\plain{\up K} Signals;Signals,TCustomComPort;TComSignal type;TComSignals type;TCustomComPort,Signals}
\b\fs28\cf1 TCustomComPort.Signals\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Indicates which signals are in high state.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComSignal = (csCTS, csDSR, csRing, csRLSD);
\par TComSignals = \b set of\plain\fs24  TComSignal;
\par \b function\plain\fs24  Signals: TComSignals;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Signals function to determine the state of signals. If a specific signal is included in the result, then the signal is in high state. To determine the change of signals use OnXChange events. Signals can determine the state of the following signals:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Signal\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 csCTS\tab \tab \tab Clear-to-send
\par csDSR\tab \tab \tab Data-set-ready
\par csRing\tab \tab \tab Ring indicator
\par csRLSD\tab \tab Receive-line-signal-detected
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Open}
{\up #}{\footnote\pard\plain{\up #} SMQ_I0}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Open;Open_Method;TCustomComPort_Open}
{\up K}{\footnote\pard\plain{\up K} Open;Open,TCustomComPort;TCustomComPort,Open}
\b\fs28\cf1 TCustomComPort.Open\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Opens a connection to serial port
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Open;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Open method connects to a serial port and sets all port settings defined in TCustomComPort properties. If a port is already opened, nothing happens.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Serial port is opened in exclusive mode. That is, once it is opened by an application, it can not be opened once again in the same or another application until it is closed.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Read}
{\up #}{\footnote\pard\plain{\up #} 6DH2XK}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Read;Read_Method;TCustomComPort_Read}
{\up K}{\footnote\pard\plain{\up K} Read;Read,TCustomComPort;TCustomComPort,Read}
\b\fs28\cf1 TCustomComPort.Read\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Reads data from input buffer.
\par \fs16 
\par \b\fs24 function\plain\fs24  Read(\b var\plain\fs24  Buffer; Count: Integer): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call Read function to read Count bytes into Buffer variable. The function does not return until Count bytes are read or timeout elapses.
\par \fs16 
\par \fs24 The return value is the number of bytes that are actually read.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 Buffer variable must be large enough to hold Count bytes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ReadAsync}
{\up #}{\footnote\pard\plain{\up #} 33R40Q0}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ReadAsync;ReadAsync_Method;TCustomComPort_ReadAsync}
{\up K}{\footnote\pard\plain{\up K} ReadAsync;ReadAsync,TCustomComPort;TCustomComPort,ReadAsync}
\b\fs28\cf1 TCustomComPort.ReadAsync\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Reads data from input buffer in asynchronous mode.
\par \fs16 
\par \b\fs24 function\plain\fs24  ReadAsync(\b var\plain\fs24  Buffer; Count: Integer; \b var\plain\fs24  AsyncPtr: PAsync): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call ReadAsync function to read Count bytes into Buffer variable. The function returns immidiately and does not wait for the operation to be completed. Call \uldb WaitForAsync\plain\fs24 {\v 44HCXR} function to make sure that the operation is completed. AsyncPtr parameter is PAsync record initialized by \uldb InitAsync\plain\fs24 {\v PIWD4U} method. The application is responsible for freeing AsyncPtr pointer with \uldb DoneAsync\plain\fs24 {\v 2_5VP2K} method after the operation is completed 
\par \pard \fs16 
\par \fs24 The return value is the number of bytes that are actually read.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 Buffer variable must be large enough to hold Count bytes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ReadStr}
{\up #}{\footnote\pard\plain{\up #} 2_E4XD.}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ReadStr;ReadStr_Method;TCustomComPort_ReadStr}
{\up K}{\footnote\pard\plain{\up K} ReadStr;ReadStr,TCustomComPort;TCustomComPort,ReadStr}
\b\fs28\cf1 TCustomComPort.ReadStr\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Reads data from input buffer into string variable.
\par \fs16 
\par \b\fs24 function\plain\fs24  ReadStr(\b var\plain\fs24  Str: \b String\plain\fs24 ; Count: Integer): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call ReadStr function to read Count bytes into Str variable. The function does not return until Count bytes are read or timeout elapses.
\par \fs16 
\par \fs24 The return value is the number of bytes that are actually read.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 Do not call ReadStr method with parameter Count set to \b 0\plain\fs24 .
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ReadStrAsync}
{\up #}{\footnote\pard\plain{\up #} YY_0P1}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ReadStrAsync;ReadStrAsync_Method;TCustomComPort_ReadStrAsync}
{\up K}{\footnote\pard\plain{\up K} ReadStrAsync;ReadStrAsync,TCustomComPort;TCustomComPort,ReadStrAsync}
\b\fs28\cf1 TCustomComPort.ReadStrAsync\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Reads data from input buffer into string variable in asynchronous mode.
\par \fs16 
\par \b\fs24 function\plain\fs24  ReadStrAsync(\b var\plain\fs24  Str: \b String\plain\fs24 ; Count: Integer; \b var\plain\fs24  AsyncPtr: PAsync): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call ReadStrAsync function to read Count bytes into Str variable. The function returns immidiately and does not wait for the operation to be completed. Call \uldb WaitForAsync\plain\fs24 {\v 44HCXR} function to make sure that the operation is completed. AsyncPtr parameter is PAsync record initialized by \uldb InitAsync\plain\fs24 {\v PIWD4U} method. The application is responsible for freeing AsyncPtr pointer with \uldb DoneAsync\plain\fs24 {\v 2_5VP2K} method after the operation is completed 
\par \pard \fs16 
\par \fs24 The return value is the number of bytes that are actually read.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 If the result of \uldb WaitForAsync\plain\fs24 {\v 44HCXR} is different than Count parameter, application must manually adjust Str parameter length using SetLength function.
\par \fs16 
\par \fs24 Do not call ReadStrAsync method with parameter Count set to \b 0\plain\fs24 .
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.Write}
{\up #}{\footnote\pard\plain{\up #} 11Y69LF}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_Write;Write;Write_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,Write;Write;Write,TCustomComPort}
\b\fs28\cf1 TCustomComPort.Write\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs16 
\par \pard \fs24 Writes data to output buffer.
\par \fs16 
\par \b\fs24 function\plain\fs24  Write(\b const\plain\fs24  Buffer; Count: Integer): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call Write function to write Count bytes from Buffer variable to output buffer. The function does not return until Count bytes are written or timeout elapses.
\par \fs16 
\par \fs24 The return value is the number of bytes that are actually written.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.WriteAsync}
{\up #}{\footnote\pard\plain{\up #} 44QH0K0}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_WriteAsync;WriteAsync;WriteAsync_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,WriteAsync;WriteAsync;WriteAsync,TCustomComPort}
\b\fs28\cf1 TCustomComPort.WriteAsync\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Writes data to output buffer in asynchronous mode.
\par \fs16 
\par \b\fs24 function\plain\fs24  WriteAsync(\b const\plain\fs24  Buffer; Count: Integer; \b var\plain\fs24  AsyncPtr: PAsync): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call WriteAsync function to write Count bytes of Buffer variable to output buffer. The function returns immidiately and does not wait for the operation to be completed. Call \uldb WaitForAsync\plain\fs24 {\v 44HCXR} function to make sure that the operation is completed. AsyncPtr parameter is PAsync record initialized by \uldb InitAsync\plain\fs24 {\v PIWD4U} method. The application is responsible for freeing AsyncPtr pointer with \uldb DoneAsync\plain\fs24 {\v 2_5VP2K} method after the operation is completed 
\par \pard \fs16 
\par \fs24 The return value is the number of bytes that are actually written.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.WriteStr}
{\up #}{\footnote\pard\plain{\up #} UMEGVS}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_WriteStr;WriteStr;WriteStr_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,WriteStr;WriteStr;WriteStr,TCustomComPort}
\b\fs28\cf1 TCustomComPort.WriteStr\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}\fs24 
\par \pard Writes string to output buffer.
\par \fs16 
\par \b\fs24 function\plain\fs24  WriteStr(\b const\plain\fs24  Str: \b String\plain\fs24 ): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Call WriteStr function to write Str variable to output buffer. The function does not return until whole string is written or timeout elapses.
\par \fs16 
\par \fs24 The return value is the number of bytes that are actually written.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.WriteStrAsync}
{\up #}{\footnote\pard\plain{\up #} JL0ZGV}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_WriteStrAsync;WriteStrAsync;WriteStrAsync_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,WriteStrAsync;WriteStrAsync;WriteStrAsync,TCustomComPort}
\b\fs28\cf1 TCustomComPort.WriteStrAsync\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Writes string to output buffer in asynchronous mode.
\par \fs16 
\par \b\fs24 function\plain\fs24  WriteStrAsync(\b const\plain\fs24  Str: \b String\plain\fs24 ; \b var\plain\fs24  AsyncPtr: PAsync): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call WriteStrAsync function to write Str variable to output buffer. The function returns immidiately and does not wait for the operation to be completed. Call \uldb WaitForAsync\plain\fs24 {\v 44HCXR} function to make sure that the operation is completed. AsyncPtr parameter is PAsync record initialized by \uldb InitAsync\plain\fs24 {\v PIWD4U} method. The application is responsible for freeing AsyncPtr pointer with \uldb DoneAsync\plain\fs24 {\v 2_5VP2K} method after the operation is completed 
\par \pard \fs16 
\par \fs24 The return value is the number of bytes that are actually written.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.SetBreak}
{\up #}{\footnote\pard\plain{\up #} 1J7W_T0}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SetBreak;SetBreak_Method;TCustomComPort_SetBreak}
{\up K}{\footnote\pard\plain{\up K} SetBreak;SetBreak,TCustomComPort;TCustomComPort,SetBreak}
\b\fs28\cf1 TCustomComPort.SetBreak\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Places or transmission in break or non-break state.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  SetBreak(OnOff: Boolean);
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Use SetBreak function to set break or non-break transmission state. OnOff parameter can be one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 True\tab \tab \tab Suspends character transmission and places the
\par \pard\li1415\fi705\tx355 transmission line in a break state
\par \pard\tx355 False\tab \tab \tab Restores character transmission and places the
\par \pard\li1415\fi705\tx355 transmission line in a nonbreak state.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.SetDTR}
{\up #}{\footnote\pard\plain{\up #} 2OD7Y7O}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SetDTR;SetDTR_Method;TCustomComPort_SetDTR}
{\up K}{\footnote\pard\plain{\up K} SetDTR;SetDTR,TCustomComPort;TCustomComPort,SetDTR}
\b\fs28\cf1 TCustomComPort.SetDTR\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Enables or diables DTR signal.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  SetDTR(OnOff: Boolean);
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Use SetDTR function to enable or disable DTR (data-terminal-ready) signal. OnOff parameter can be one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 True\tab \tab \tab Sets DTR signal
\par \pard\tx355 \fs20 False\tab \tab \tab Clears DTR signal
\par \pard\tx355 \fs16 
\par \pard\tx355 \b\fs20 Note
\par \pard\tx355 \plain\fs24 If \uldb FlowControl.ControlDTR\plain\fs24 {\v AM7AV0} property is set to dtrHandshake, it is an error for the application to call SetDTR function and \uldb EComPort\plain\fs24 {\v T2D5VU} exception is raised.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.SetRTS}
{\up #}{\footnote\pard\plain{\up #} 2OD8.7P}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SetRTS;SetRTS_Method;TCustomComPort_SetRTS}
{\up K}{\footnote\pard\plain{\up K} SetRTS;SetRTS,TCustomComPort;TCustomComPort,SetRTS}
\b\fs28\cf1 TCustomComPort.SetRTS\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Enables or diables RTS signal.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  SetRTS(OnOff: Boolean);
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Use SetRTS function to enable or disable RTS (request-to-send) signal. OnOff parameter can be one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 True\tab \tab \tab Sets RTS signal
\par \pard\tx355 \fs20 False\tab \tab \tab Clears RTS signal
\par \pard\tx355 \fs16 
\par \pard\tx355 \b\fs20 Note
\par \pard\tx355 \plain\fs24 If \uldb FlowControl.ControlRTS\plain\fs24 {\v 13VCOBK} property is set to rtsHandshake, it is an error for the application to call SetRTS function and \uldb EComPort\plain\fs24 {\v T2D5VU} exception is raised.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.SetXonXoff}
{\up #}{\footnote\pard\plain{\up #} FWQ6FI}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SetXonXoff;SetXonXoff_Method;TCustomComPort_SetXonXoff}
{\up K}{\footnote\pard\plain{\up K} SetXonXoff;SetXonXoff,TCustomComPort;TCustomComPort,SetXonXoff}
\b\fs28\cf1 TCustomComPort.SetXonXoff\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Simulates Xon/Xoff charachter.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  SetXonXoff(OnOff: Boolean);
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Use SetXonXoff function to simulate Xon/Xoff charachter arrival. OnOff parameter can be one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 True\tab \tab \tab Causes transmission to act as if an Xon character
\par \pard\li1415\fi705\tx355 has been received.
\par \pard\tx355 \fs20 False\tab \tab \tab Causes transmission to act as if an Xoff character
\par \pard\li1415\fi705\tx355 has been received.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.SetupComPort}
{\up #}{\footnote\pard\plain{\up #} 11YY14Y}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SetupComPort;SetupComPort_Method;TCustomComPort_SetupComPort}
{\up K}{\footnote\pard\plain{\up K} SetupComPort;SetupComPort,TCustomComPort;TCustomComPort,SetupComPort}
\b\fs28\cf1 TCustomComPort.SetupComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Sets serial port settings.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  SetupComPort; \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 This method is called in \uldb Open\plain\fs24 {\v SMQ_I0} method after \uldb CreateHandle\plain\fs24 {\v HVRNGN} method. SetupComPort calls \uldb ApplyDCB\plain\fs24 {\v 7_KA86}, \uldb ApplyTimeouts\plain\fs24 {\v 2BHPKBZ} and \uldb ApplyBuffer\plain\fs24 {\v AU_VIM} methods to set serial port settings. Descendants can override this function to add additional settings.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.ShowSetupDialog}
{\up #}{\footnote\pard\plain{\up #} 17MJC_D}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ShowSetupDialog;ShowSetupDialog_Method;TCustomComPort_ShowSetupDialog}
{\up K}{\footnote\pard\plain{\up K} ShowSetupDialog;ShowSetupDialog,TCustomComPort;TCustomComPort,ShowSetupDialog}
\b\fs28\cf1 TCustomComPort.ShowSetupDialog\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Shows a serial port setup dialog box.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ShowSetupDialog;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call ShowSetupDialog method to open a setup dialog for serial port. If port is already opened and user clicks OK button, changes are applied without reopening the port.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.StateFlags}
{\up #}{\footnote\pard\plain{\up #} BZP_YG}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StateFlags;StateFlags_Method;TCustomComPort_StateFlags}
{\up K}{\footnote\pard\plain{\up K} StateFlags;StateFlags,TCustomComPort;TCustomComPort,StateFlags}
\b\fs28\cf1 TCustomComPort.StateFlags\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Returns serial port state flags.
\par \fs16 
\par \fs24 TComStateFlag = (fCtlHold, fDsrHold, fRlsHold, fXoffHold, fXOffSent, fEof, fTxim);
\par TComStateFlags = \b set of \plain\fs24 TComStateFlag;
\par \b function\plain\fs24  StateFlags: TComStateFlags;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Call StateFlags function to obtain information about serial communication device. Flags have the following meaning:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Flag\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 fCtlHold\tab \tab Specifies whether transmission is waiting for the
\par \pard\li1415\fi705\tx355 CTS (clear-to-send) signal to be sent. If this flag is
\par \pard\li1415\fi705\tx355 set, transmission is waiting.
\par \pard\tx355 fDsrHold\tab \tab Specifies whether transmission is waiting for the
\par \pard\li1415\fi705\tx355 DSR (data-set-ready) signal to be sent. If this flag is
\par \pard\li1415\fi705\tx355 set, transmission is waiting.
\par \pard\tx355 fRlsHold\tab \tab Specifies whether transmission is waiting for the
\par \pard\li1415\fi705\tx355 RLSD (receive-line-signal-detect) signal to be sent.
\par \pard\li1415\fi705\tx355 If this flag is set, transmission is waiting.
\par \pard\tx355 fXoffHold\tab \tab Specifies whether transmission is waiting because
\par \pard\li1415\fi705\tx355 the Xoff character was received. If this flag is set,
\par \pard\li1415\fi705\tx355 transmission is waiting.
\par \pard\tx355 fXoffSent\tab \tab Specifies whether transmission is waiting because
\par \pard\li1415\fi705\tx355 the Xoff character was transmitted. If this flag is set,
\par \pard\li1415\fi705\tx355 transmission is waiting. Transmission halts when the
\par \pard\li1415\fi705\tx355 Xoff character is transmitted to a system that takes the
\par \pard\li1415\fi705\tx355 next character as Xon, regardless of the actual character.
\par \pard\tx355 fEof\tab \tab \tab Specifies whether the end-of-file (EOF) character has
\par \pard\li1415\fi705\tx355 been received. If this flag is set, the EOF character has
\par \pard\li1415\fi705\tx355 been received.
\par \pard\tx355 fTxim\tab \tab \tab If this flag is set, there is a character queued for
\par \pard\li1415\fi705\tx355 transmission that has come to the communications
\par \pard\li1415\fi705\tx355 device by way of the \uldb TransmitChar\plain\fs24 {\v 1_UCTVO} function.
\par \pard\li1415\fi705\tx355 The communications device transmits such a character
\par \pard\li1415\fi705\tx355 ahead of other characters in the device's output buffer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.TransmitChar}
{\up #}{\footnote\pard\plain{\up #} 1_UCTVO}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_TransmitChar;TransmitChar;TransmitChar_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,TransmitChar;TransmitChar;TransmitChar,TCustomComPort}
\b\fs28\cf1 TCustomComPort.TransmitChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Transmits a charachter.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  TransmitChar(Ch: Char);
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Use TransmitChar method to transmit a charachter ahead of any pending data in output buffer. The function is useful for sending an interrupt character (such as a CTRL+C) to a host system.
\par \fs16 
\par \fs24 Character transmission is subject to normal flow control and handshaking.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs20 If the device is not transmitting, TransmitChar cannot be called repeatedly. Once TransmitChar places a character in the output buffer, the character must be transmitted before the function can be called again. If the previous character has not yet been sent, TransmitChar raises an error.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.WaitForAsync}
{\up #}{\footnote\pard\plain{\up #} 44HCXR}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_WaitForAsync;WaitForAsync;WaitForAsync_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,WaitForAsync;WaitForAsync;WaitForAsync,TCustomComPort}
\b\fs28\cf1 TCustomComPort.WaitForAsync\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Waits until asynchronous operation is completed.
\par \fs16 
\par \b\fs24 function\plain\fs24  WaitForAsync(\b var\plain\fs24  AsyncPtr: PAsync): Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Call WaitForAsync function to make sure that asynchronous operation is completed. WaitForAsync does not return until operation is finished or aborted. AsyncPtr parameter is a variable initialized by \uldb InitAsync\plain\fs20 {\v PIWD4U} method.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs20 Application is still responsible to free AsyncPtr variable using \uldb DoneAsync\plain\fs20 {\v 2_5VP2K} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.WaitForEvent}
{\up #}{\footnote\pard\plain{\up #} 48JZY8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComPort_WaitForEvent;WaitForEvent;WaitForEvent_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComPort,WaitForEvent;WaitForEvent;WaitForEvent,TCustomComPort}
\b\fs28\cf1 TCustomComPort.WaitForEvent\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Waits for event to occur on port.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  WaitForEvent(\b var\plain\fs24  Events: TComEvents; StopEvent: TEvent; Timeout: Integer);
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Call WaitForEvent method to wait for event to occur on serial port. Method returns when event occurs or timeout elapses. Events parameter defines which events should be monitored and returns events that have occured. StopEvent parameter is Win API event that cancels wait operation if application turns it on. Timeout parameter is number of milliseconds the application should wait. If you set Timeout parameter to WaitInfinite constant, the method does not return until at least one event occurs.
\par \pard \fs16 
\par \b\fs20 Note
\par \plain\fs20 WaitForEvent method is useful only when \uldb Events\plain\fs20 {\v 2ATT87P} property is set to empty before \uldb Open\plain\fs20 {\v SMQ_I0} method is called. If Events is not empty, a special thread is created which already calls wait function and all events are handled in OnX event handlers.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnAfterClose}
{\up #}{\footnote\pard\plain{\up #} JLKPS4}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnAfterClose;OnAfterClose_Event;TCustomComPort_OnAfterClose}
{\up K}{\footnote\pard\plain{\up K} OnAfterClose;OnAfterClose,TCustomComPort;TCustomComPort,OnAfterClose}
\b\fs28\cf1 TCustomComPort.OnAfterClose\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs after serial port is closed.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnClose: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnAfterClose event handler to take specific action after serial port is successfully closed using \uldb Close\plain\fs20 {\v 54QM.VP} method or \uldb Connected\plain\fs20 {\v 3JRPNVU} property. If closing of serial port fails, OnAfterClose event is not triggered.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnBeforeClose}
{\up #}{\footnote\pard\plain{\up #} 0LG1MF}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnBeforeClose;OnBeforeClose_Event;TCustomComPort_OnBeforeClose}
{\up K}{\footnote\pard\plain{\up K} OnBeforeClose;OnBeforeClose,TCustomComPort;TCustomComPort,OnBeforeClose}
\b\fs28\cf1 TCustomComPort.OnBeforeClose\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs before serial port is closed.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnBeforeClose: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnBeforeClose event handler to take specific action before serial port is successfully closed using \uldb Close\plain\fs20 {\v 54QM.VP} method or \uldb Connected\plain\fs20 {\v 3JRPNVU} property. If exception is raised inside OnBeforeClose event handler, port is not closed.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnAfterOpen}
{\up #}{\footnote\pard\plain{\up #} 3.XSO_P}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnAfterOpen;OnAfterOpen_Event;TCustomComPort_OnAfterOpen}
{\up K}{\footnote\pard\plain{\up K} OnAfterOpen;OnAfterOpen,TCustomComPort;TCustomComPort,OnAfterOpen}
\b\fs28\cf1 TCustomComPort.OnAfterOpen\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs after serial port is opened.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnAfterOpen: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnAfterOpen event handler to take specific action after serial port is successfully opened using \uldb Open\plain\fs20 {\v SMQ_I0} method or \uldb Connected\plain\fs20 {\v 3JRPNVU} property. If opening of serial port fails, OnAfterOpen event is not triggered.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnBeforeOpen}
{\up #}{\footnote\pard\plain{\up #} 5MLTNW}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnBeforeOpen;OnBeforeOpen_Event;TCustomComPort_OnBeforeOpen}
{\up K}{\footnote\pard\plain{\up K} OnBeforeOpen;OnBeforeOpen,TCustomComPort;TCustomComPort,OnBeforeOpen}
\b\fs28\cf1 TCustomComPort.OnBeforeOpen\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs before serial port is opened.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnBeforeOpen: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnBeforeOpen event handler to take specific action after serial port is successfully opened using \uldb Open\plain\fs20 {\v SMQ_I0} method or \uldb Connected\plain\fs20 {\v 3JRPNVU} property. If exception is raised inside OnBeforeOpen event handler, port is not opened.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnTxEmpty}
{\up #}{\footnote\pard\plain{\up #} CLAQ6F}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnTxEmpty;OnTxEmpty_Event;TCustomComPort_OnTxEmpty}
{\up K}{\footnote\pard\plain{\up K} OnTxEmpty;OnTxEmpty,TCustomComPort;TCustomComPort,OnTxEmpty}
\b\fs28\cf1 TCustomComPort.OnTxEmpty\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when output buffer becomes empty.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnTxEmpty: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnTxEmpty event handler to take specific action when output buffer becomes empty, that is, all charachters in output buffer have been transmitted.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnRx80Full}
{\up #}{\footnote\pard\plain{\up #} 1.GB4HU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnRx80Full;OnRx80Full_Event;TCustomComPort_OnRx80Full}
{\up K}{\footnote\pard\plain{\up K} OnRx80Full;OnRx80Full,TCustomComPort;TCustomComPort,OnRx80Full}
\b\fs28\cf1 TCustomComPort.OnRx80Full\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when input buffer is 80% full.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnRx80Full: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnRx80Full event handler to take specific action when input buffer becomes 80 percent full. This is a warning to application that a input buffer overflow could occur unless there is some kind of flow control set.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnRxFlag}
{\up #}{\footnote\pard\plain{\up #} .1ZY8N}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnRxFlag;OnRxFlag_Event;TCustomComPort_OnRxFlag}
{\up K}{\footnote\pard\plain{\up K} OnRxFlag;OnRxFlag,TCustomComPort;TCustomComPort,OnRxFlag}
\b\fs28\cf1 TCustomComPort.OnRxFlag\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when event charachter arrives.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnRxFlag: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnRxFlag event handler to take specific action when event charachter arrives. Set \uldb EventChar\plain\fs20 {\v HZ4SCA} property to set event charachter ASCII code.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs20 An event charachter is also placed in input buffer. The only difference between event and non-event charachter is that event charachter triggers \uldb OnRxChar\plain\fs20 {\v .1WU8Y} and \uldb OnRxFlag\plain\fs20  events, while non-event charachter triggers only \uldb OnRxChar\plain\fs20 {\v .1WU8Y} event.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnBreak}
{\up #}{\footnote\pard\plain{\up #} 8ONIHE}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnBreak;OnBreak_Event;TCustomComPort_OnBreak}
{\up K}{\footnote\pard\plain{\up K} OnBreak;OnBreak,TCustomComPort;TCustomComPort,OnBreak}
\b\fs28\cf1 TCustomComPort.OnBreak\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when break is detected on input.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnBreak: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnBreak event handler to take specific action when hardware detects a break on input.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnRxChar}
{\up #}{\footnote\pard\plain{\up #} .1WU8Y}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnRxChar;OnRxChar_Event;TCustomComPort_OnRxChar}
{\up K}{\footnote\pard\plain{\up K} OnRxChar;OnRxChar,TCustomComPort;TCustomComPort,OnRxChar;TRxCharEvent type}
\b\fs28\cf1 TCustomComPort.OnRxChar\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when charachter arrives in input buffer.
\par \fs16 
\par \b\fs24 type\plain\fs24  TRxCharEvent = \b procedure\plain\fs24 (Sender: TObject; Count: Integer) \b of object\plain\fs24 ;
\par \b\fs20 property\plain\fs20  OnRxChar: TRxCharEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnRxChar event handler to get information about recently arrived charachters in input buffer. Count parameter is the number of bytes in input buffer waiting to be read. OnRxChar event is usually used for reading charachters from input buffer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnRxBuf}
{\up #}{\footnote\pard\plain{\up #} 1HGAF55}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnRxBuf;OnRxBuf_Event;TCustomComPort_OnRxBuf}
{\up K}{\footnote\pard\plain{\up K} OnRxBuf;OnRxBuf,TCustomComPort;TCustomComPort,OnRxBuf;TRxBufEvent type}
\b\fs28\cf1 TCustomComPort.OnRxBuf\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when data has been read from input buffer.
\par \fs16 
\par \b\fs24 type\plain\fs24  TRxBufEvent = \b procedure\plain\fs24 (Sender: TObject; \b const\plain\fs24  Buffer; Count: Integer) \b of object\plain\fs24 ;
\par \b\fs20 property\plain\fs20  OnRxBuf: TRxBufEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnRxChar event handler to get data that had arrived in input buffer, but it has already been read from it by other linked component such as \uldb TComDataPacket\plain\fs20 {\v 82GU66} or \uldb TCustomComTerminal\plain\fs20 {\v ZHXVI6}. The application can not read the data from input buffer, because it has already been read from it and placed in Buffer parameter.
\par \pard \fs16 
\par \b\fs20 Note
\par \plain\fs20 Application can check whether OnRxBuf or OnRxChar event is called with \uldb TriggersOnRxChar\plain\fs20 {\v 3YS4_IF} property.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnCTSChange}
{\up #}{\footnote\pard\plain{\up #} 1AQGUQ8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnCTSChange;OnCTSChange_Event;TCustomComPort_OnCTSChange}
{\up K}{\footnote\pard\plain{\up K} OnCTSChange;OnCTSChange,TCustomComPort;TComSignalEvent type;TCustomComPort,OnCTSChange}
\b\fs28\cf1 TCustomComPort.OnCTSChange\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when CTS signal state has changed.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComSignalEvent = \b procedure\plain\fs24 (Sender: TObject; OnOff: Boolean) \b of\plain\fs24  \b object\plain\fs24 ;
\par \b\fs20 property\plain\fs20  OnCTSChange: TComSignalEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnCTSChange event handler to take specific action when CTS (clear-to-send) signal has changed state. If OnOff parameter is True, CTS has changed from low to high state. If OnOff parameter is False, CTS has changed from high to low state.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnDSRChange}
{\up #}{\footnote\pard\plain{\up #} D9C427}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnDSRChange;OnDSRChange_Event;TCustomComPort_OnDSRChange}
{\up K}{\footnote\pard\plain{\up K} OnDSRChange;OnDSRChange,TCustomComPort;TCustomComPort,OnDSRChange}
\b\fs28\cf1 TCustomComPort.OnDSRChange\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when DSR signal state has changed.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComSignalEvent = \b procedure\plain\fs24 (Sender: TObject; OnOff: Boolean) \b of\plain\fs24  \b object\plain\fs24 ;
\par \b\fs20 property\plain\fs20  OnDSRChange: TComSignalEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnDSRChange event handler to take specific action when DSR (data-set-ready) signal has changed state. If OnOff parameter is True, DSR has changed from low to high state. If OnOff parameter is False, DSR has changed from high to low state.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnRLSDChange}
{\up #}{\footnote\pard\plain{\up #} 603U0G}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnRLSDChange;OnRLSDChange_Event;TCustomComPort_OnRLSDChange}
{\up K}{\footnote\pard\plain{\up K} OnRLSDChange;OnRLSDChange,TCustomComPort;TCustomComPort,OnRLSDChange}
\b\fs28\cf1 TCustomComPort.OnRLSDChange\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when RLSD signal state has changed.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComSignalEvent = \b procedure\plain\fs24 (Sender: TObject; OnOff: Boolean) \b of\plain\fs24  \b object\plain\fs24 ;
\par \b\fs20 property\plain\fs20  OnRLSDChange: TComSignalEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnRLSDChange event handler to take specific action when RLSD (receive-line-signal-detected) signal has changed state. If OnOff parameter is True, RLSD has changed from low to high state. If OnOff parameter is False, RLSD has changed from high to low state.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnRing}
{\up #}{\footnote\pard\plain{\up #} 1.0I3XO}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnRing;OnRing_Event;TCustomComPort_OnRing}
{\up K}{\footnote\pard\plain{\up K} OnRing;OnRing,TCustomComPort;TCustomComPort,OnRing}
\b\fs28\cf1 TCustomComPort.OnRing\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs when Ring indicator is detected.
\par \fs16 
\par \b\fs20 property\plain\fs20  OnRing: TNotifyEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnRing event handler to take specific action when Ring indicator is detected. This event is mainly used when programming modem application.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComPort.OnError}
{\up #}{\footnote\pard\plain{\up #} 8RNVVL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnError;OnError_Event;TCustomComPort_OnError}
{\up K}{\footnote\pard\plain{\up K} OnError;OnError,TCustomComPort;TComErrorEvent type;TCustomComPort,OnError}
\b\fs28\cf1 TCustomComPort.OnError\plain\fs20 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard Occurs on line status error.
\par \fs16 
\par \fs24 TComErrorEvent\b  = procedure\plain\fs24 (Sender: TObject; Errors: TComErrors) \b of object\plain\fs24 ;\b 
\par \fs20 property\plain\fs20  OnError: TComErrorEvent;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Write OnError event handler to take specific action when a line status error occurs. Line status errors are ceFrame, ceOverrun, ceRxParity.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs20 If application calls \uldb LastErrors\plain\fs20 {\v 1KVBTD} method inside OnError event, it returns empty result set. Use Errors paramater instead.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket}
{\up #}{\footnote\pard\plain{\up #} 82GU66}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComDataPacket_Object,TComDataPacket}
{\up K}{\footnote\pard\plain{\up K} TComDataPacket}
\b\fs28\cf1 \{bml bm5.BMP\} TComDataPacket\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 1CHSEO8}       \uldb Properties\plain\fs20 {\v I.V41L>props}       \uldb Methods\plain\fs20 {\v 8RTEZY>props}       \uldb Events\plain\fs20 {\v 3Z.9_T.>props}
\par \pard TComData packet performs read operation in packets.\b 
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPort
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par \fs24 Use TComDataPacket component to easily read data from input buffer in packets. The application can set stop and start condition for packet by setting TComDataPacket properties. One \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component can have more than one TComDataPacket component linked.
\par \page
{\up #}{\footnote\pard\plain{\up #} 1CHSEO8}
\pard \b Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TComDataPacket
\par \page
{\up #}{\footnote\pard\plain{\up #} I.V41L}
\pard\keepn \b\cf1 TComDataPacket properties\plain\fs24 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComDataPacket
\par \plain\fs20 \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Buffer\plain\fs20 {\v 15Z7MY>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb CaseInsensitive\plain\fs20 {\v XKR3E9>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ComPort\plain\fs20 {\v KNTXV4>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb IncludeStrings\plain\fs20 {\v 189I.I7>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb MaxBufferSize\plain\fs20 {\v 5EJK0ZE>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Size\plain\fs20 {\v 1HM024>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb StartString\plain\fs20 {\v 022FNL>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb StopString\plain\fs20 {\v 42YS_ZI>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 8RTEZY}
\pard\keepn \b\fs24\cf1 TComDataPacket methods\plain\fs24 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \fs16 
\par \b\fs20 In TComDataPacket
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb AddData\plain\fs20 {\v B6AIGQ>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 22Y31L>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v 2BA1OD>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoDiscard\plain\fs20 {\v 28B1G8>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoPacket\plain\fs20 {\v 52LS06>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb HandleBuffer\plain\fs20 {\v AQXGJL>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Notification\plain\fs20 {\v 4P3GI5>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 3Z.9_T.}
\pard\keepn \b\fs24\cf1 TComDataPacket events\plain\fs24 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \fs16 
\par \b\fs20 In TComDataPacket
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnCustomStart\plain\fs20 {\v NC61WH>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnCustomStop\plain\fs20 {\v 2HQA_KW>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnDiscard\plain\fs20 {\v IBN5GA>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnPacket\plain\fs20 {\v 1XOO74L>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.ComPort}
{\up #}{\footnote\pard\plain{\up #} KNTXV4}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComDataPacket_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComDataPacket;TComDataPacket,ComPort}
\b\fs28\cf1 TComDataPacket.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Specifies the TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ComPort property to link TComDataPacket component with \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component. The component gets all data from ComPort component. More than one TComDataPacket component can have the same ComPort component linked.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.CaseInsensitive}
{\up #}{\footnote\pard\plain{\up #} XKR3E9}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} CaseInsensitive;CaseInsensitive_Property;TComDataPacket_CaseInsensitive}
{\up K}{\footnote\pard\plain{\up K} CaseInsensitive;CaseInsensitive,TComDataPacket;TComDataPacket,CaseInsensitive}
\b\fs28\cf1 TComDataPacket.CaseInsensitive\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Specifies case sensitivity for start and stop strings.
\par \fs16 
\par \b\fs24 property\plain\fs24  CaseInsensitive: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set CaseInsensitive property to specify case sensitivity of \uldb StartString\plain\fs24 {\v 022FNL} and \uldb StopString\plain\fs24 {\v 42YS_ZI} properties. If CaseInsensitive is True, TComDataPacket ignores case. If CaseInsensitive is False, TComDataPacket does not ignore case.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.MaxBufferSize}
{\up #}{\footnote\pard\plain{\up #} 5EJK0ZE}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} MaxBufferSize;MaxBufferSize_Property;TComDataPacket_MaxBufferSize}
{\up K}{\footnote\pard\plain{\up K} MaxBufferSize;MaxBufferSize,TComDataPacket;TComDataPacket,MaxBufferSize}
\b\fs28\cf1 TComDataPacket.MaxBufferSize\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Specifies maximum buffer size.
\par \fs16 
\par \b\fs24 property\plain\fs24  MaxBufferSize: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Use MaxBufferSize to set maximum size of packet buffer. If buffer size reaches MaxBufferSize, buffer is discarded and current packet in buffer is removed.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.IncludeStrings}
{\up #}{\footnote\pard\plain{\up #} 189I.I7}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} IncludeStrings;IncludeStrings_Property;TComDataPacket_IncludeStrings}
{\up K}{\footnote\pard\plain{\up K} IncludeStrings;IncludeStrings,TComDataPacket;TComDataPacket,IncludeStrings}
\b\fs28\cf1 TComDataPacket.IncludeStrings\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Specifies whether start and stop strings are included.
\par \fs16 
\par \b\fs24 property\plain\fs24  IncludeStrings: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Set IncludeStrings property to specify whether \uldb StartString\plain\fs20 {\v 022FNL} and \uldb StopString\plain\fs20 {\v 42YS_ZI} strings are included in packet. If IncludeStrings is False, start and stop strings are not included inside \uldb OnPacket\plain\fs20 {\v 1XOO74L} event.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.StartString}
{\up #}{\footnote\pard\plain{\up #} 022FNL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StartString;StartString_Property;TComDataPacket_StartString}
{\up K}{\footnote\pard\plain{\up K} StartString;StartString,TComDataPacket;TComDataPacket,StartString}
\b\fs28\cf1 TComDataPacket.StartString\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Specifies start string.
\par \fs16 
\par \b\fs24 property\plain\fs24  StartString: String;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Use StartString property to set start condition for packet. If StartString is not empty, packet starts when StartString charachters arrive in input buffer. If StartString is empty, packet starts immidiately when any charachter arrives in input buffer.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs20 If TComDataPacket has \uldb OnCustomStart\plain\fs20 {\v NC61WH} event assigned, StartString value is ignored and start condition is defined inside OnCustomStart event handler.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.StopString}
{\up #}{\footnote\pard\plain{\up #} 42YS_ZI}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} StopString;StopString_Property;TComDataPacket_StopString}
{\up K}{\footnote\pard\plain{\up K} StopString;StopString,TComDataPacket;TComDataPacket,StopString}
\b\fs28\cf1 TComDataPacket.StopString\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Specifies stop string.
\par \fs16 
\par \b\fs24 property\plain\fs24  StopString: String;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Use StopString property to set stop condition for packet. If StopString is not empty, packet ends when StopString charachters arrive in input buffer. After packet is finished, \uldb OnPacket\plain\fs20 {\v 1XOO74L} event occurs.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 If \uldb Size\plain\fs24 {\v 1HM024} is not 0 and greater than current packet length, packet is immidately ended regardless of StopString occurance in packet. If Size is 0 and StopString is empty, OnPacket event has the same function as \uldb OnRxBuf\plain\fs24 {\v 1HGAF55} event of \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component.
\par \pard \fs16 
\par \fs20 If TComDataPacket has \uldb OnCustomStop\plain\fs20 {\v 2HQA_KW} event assigned, both StopString and Size value are ignored and stop condition is defined inside OnCustomStop event handler.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.Size}
{\up #}{\footnote\pard\plain{\up #} 1HM024}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Size;Size_Property;TComDataPacket_Size}
{\up K}{\footnote\pard\plain{\up K} Size;Size,TComDataPacket;TComDataPacket,Size}
\b\fs28\cf1 TComDataPacket.Size\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Specifies size stop condition.
\par \fs16 
\par \b\fs24 property\plain\fs24  Size: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Size property to set stop condition for packet. If current packet size is equal or greater than Size, packet is ended and \uldb OnPacket\plain\fs24 {\v 1XOO74L} event is triggered. If Size is 0, size stop condition is not used.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 If \uldb StopString\plain\fs24 {\v 42YS_ZI} is not empty and StopString charachters are found in packet, packet is immidiately ended regardless of its size. If StopString is empty and Size is 0, \uldb OnPacket\plain\fs24 {\v 1XOO74L} event has the same function as \uldb OnRxBuf\plain\fs24 {\v 1HGAF55} event of \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component.
\par \pard \fs16 
\par \fs20 If TComDataPacket has \uldb OnCustomStop\plain\fs20 {\v 2HQA_KW} event assigned, both StopString and Size value are ignored and stop condition is defined inside OnCustomStop event handler.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.Buffer}
{\up #}{\footnote\pard\plain{\up #} 15Z7MY}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Buffer;Buffer_Property;TComDataPacket_Buffer}
{\up K}{\footnote\pard\plain{\up K} Buffer;Buffer,TComDataPacket;TComDataPacket,Buffer}
\b\fs28\cf1 TComDataPacket.Buffer\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Stores incoming data.
\par \fs16 
\par \b\fs24 property\plain\fs24  Buffer: String;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Buffer property to access raw data from \uldb ComPort\plain\fs24 {\v KNTXV4} component.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.OnPacket}
{\up #}{\footnote\pard\plain{\up #} 1XOO74L}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnPacket;OnPacket_Event;TComDataPacket_OnPacket}
{\up K}{\footnote\pard\plain{\up K} OnPacket;OnPacket,TComDataPacket;TComDataPacket,OnPacket;TComStrEvent type}
\b\fs28\cf1 TComDataPacket.OnPacket\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Occurs when packet ends.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComStrEvent = \b procedure\plain\fs24 (Sender: TObject; \b const\plain\fs24  Str: \b string\plain\fs24 ) \b of object\plain\fs24 ;
\par \b property\plain\fs24  OnPacket: TComStrEvent;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Write OnPacket event to take action when packet is formed. Packet ends when one of stop conditions occurs. Parameter Str holds packet string.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.OnDiscard}
{\up #}{\footnote\pard\plain{\up #} IBN5GA}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnDiscard;OnDiscard_Event;TComDataPacket_OnDiscard}
{\up K}{\footnote\pard\plain{\up K} OnDiscard;OnDiscard,TComDataPacket;TComDataPacket,OnDiscard}
\b\fs28\cf1 TComDataPacket.OnDiscard\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Occurs when data is discarded.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComStrEvent = \b procedure\plain\fs24 (Sender: TObject; \b const\plain\fs24  Str: \b string\plain\fs24 ) \b of object\plain\fs24 ;
\par \b property\plain\fs24  OnDiscard: TComStrEvent;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Write OnDiscard event to specific take action when data is discarded. Any data that does not appear in \uldb OnPacket\plain\fs24 {\v 1XOO74L} event goes through OnDiscard event.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.OnCustomStart}
{\up #}{\footnote\pard\plain{\up #} NC61WH}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnCustomStart;OnCustomStart_Event;TComDataPacket_OnCustomStart}
{\up K}{\footnote\pard\plain{\up K} OnCustomStart;OnCustomStart,TComDataPacket;TComDataPacket,OnCustomStart;TCustPacketEvent type}
\b\fs28\cf1 TComDataPacket.OnCustomStart\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Occurs when component needs start position of custom packet.
\par \fs16 
\par \b\fs24 type\plain\fs24  TCustPacketEvent = \b procedure\plain\fs24 (Sender: TObject; \b const\plain\fs24  Str: \b string\plain\fs24 ; \b var\plain\fs24  Pos: Integer) \b of object\plain\fs24 ;
\par \b property\plain\fs24  OnCustomStart: TCustPacketEvent;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Write OnCustomStart event to form custom packet. If TComDataPacket has OnCustomStart event handler assigned, start condition is defined inside OnCustomStart event handler. Str parameter is current buffer. Pos parameter is position where packet starts. Application has to set Pos parameter to define packet start position. If no data in Str parameter matches custom start condition, application should set Pos parameter to 0.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.OnCustomStop}
{\up #}{\footnote\pard\plain{\up #} 2HQA_KW}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnCustomStop;OnCustomStop_Event;TComDataPacket_OnCustomStop}
{\up K}{\footnote\pard\plain{\up K} OnCustomStop;OnCustomStop,TComDataPacket;TComDataPacket,OnCustomStop;TCustPacketEvent type}
\b\fs28\cf1 TComDataPacket.OnCustomStop\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Occurs when component needs stop position of custom packet.
\par \fs16 
\par \b\fs24 type\plain\fs24  TCustPacketEvent = \b procedure\plain\fs24 (Sender: TObject; \b const\plain\fs24  Str: \b string\plain\fs24 ; \b var\plain\fs24  Pos: Integer) \b of object\plain\fs24 ;
\par \b property\plain\fs24  OnCustomStop: TCustPacketEvent;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Write OnCustomStop event to form custom packet. If TComDataPacket has OnCustomStop event handler assigned, stop condition is defined inside OnCustomStop event handler. Str parameter is current buffer. Pos parameter is position where packet stops. Application has to set Pos parameter to define packet stop position. If no data in Str parameter matches custom stop condition, application should set Pos parameter to 0.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.Create}
{\up #}{\footnote\pard\plain{\up #} 22Y31L}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComDataPacket_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComDataPacket;TComDataPacket,Create}
\b\fs28\cf1 TComDataPacket.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Creates an instance of TComDataPacket component.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(AOwner: TComponent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Create to programatically create TComDataPacket object. TComDataPacket component that is put on a form is automatically created.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.Destroy}
{\up #}{\footnote\pard\plain{\up #} 2BA1OD}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Destroy;Destroy_Method;TComDataPacket_Destroy}
{\up K}{\footnote\pard\plain{\up K} Destroy;Destroy,TComDataPacket;TComDataPacket,Destroy}
\b\fs28\cf1 TComDataPacket.Destroy\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Destroys an instance of TComDataPacket component.
\par \fs16 
\par \b\fs24 destructor\plain\fs24  Destroy; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TComDataPacket component is not already freed, and only then calls Destroy.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.AddData}
{\up #}{\footnote\pard\plain{\up #} B6AIGQ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AddData;AddData_Method;TComDataPacket_AddData}
{\up K}{\footnote\pard\plain{\up K} AddData;AddData,TComDataPacket;TComDataPacket,AddData}
\b\fs28\cf1 TComDataPacket.AddData\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Creates an instance of TComDataPacket component.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  AddData(\b const\plain\fs24  Str: \b string\plain\fs24 );
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Use AddData method add non-comport related data to packet buffer. This method is useful when application needs to form packets from data which arrives from other sources, such as TCP/IP protocol.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.Notification}
{\up #}{\footnote\pard\plain{\up #} 4P3GI5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Notification;Notification_Method;TComDataPacket_Notification}
{\up K}{\footnote\pard\plain{\up K} Notification;Notification,TComDataPacket;TComDataPacket,Notification}
\b\fs28\cf1 TComDataPacket.Notification\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComDataPacket\plain\fs20 {\v 82GU66>main}
\par \pard \fs24 Responds to notifications when objects are about to be created or destroyed.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Notification(AComponent: TComponent; Operation: TOperation); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Notification is called automatically when components are created or destroyed. After calling the inherited method, Notification checks whether the \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component specified by the \uldb ComPort\plain\fs24 {\v KNTXV4} property is about to be destroyed. If the component is being destroyed, Notification sets the ComPort property to nil.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.DoPacket}
{\up #}{\footnote\pard\plain{\up #} 52LS06}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoPacket;DoPacket_Method;TComDataPacket_DoPacket}
{\up K}{\footnote\pard\plain{\up K} DoPacket;DoPacket,TComDataPacket;TComDataPacket,DoPacket}
\b\fs28\cf1 TComDataPacket.DoPacket\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnPacket event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoPacket(Str: \b String\plain\fs24 ); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When packet is formed, DoPacket method is called. DoPacket method calls \uldb OnPacket\plain\fs24 {\v 1XOO74L} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoPacket method directly, since it is called by TComDataPacket automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.HandleBuffer}
{\up #}{\footnote\pard\plain{\up #} AQXGJL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} HandleBuffer;HandleBuffer_Method;TComDataPacket_HandleBuffer}
{\up K}{\footnote\pard\plain{\up K} HandleBuffer;HandleBuffer,TComDataPacket;TComDataPacket,HandleBuffer}
\b\fs28\cf1 TComDataPacket.HandleBuffer\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Splits data in packets.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  HandleBuffer; \b virtual\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par HandleBuffer method is called after data is read from input buffer and put into \uldb Buffer\plain\fs24 {\v 15Z7MY} property. HandleBuffer splits incoming data into packets using start and stop conditions. Descandants can override this function to perform custom packet splitting.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComDataPacket.DoDiscard}
{\up #}{\footnote\pard\plain{\up #} 28B1G8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoDiscard;DoDiscard_Method;TComDataPacket_DoDiscard}
{\up K}{\footnote\pard\plain{\up K} DoDiscard;DoDiscard,TComDataPacket;TComDataPacket,DoDiscard}
\b\fs28\cf1 TComDataPacket.DoDiscard\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComPort\plain\fs20 {\v 1W4XK_N>main}
\par \pard \fs24 Calls OnDiscard event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoDiscard(Str: \b String\plain\fs24 ); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par When data is discarded, DoDiscard method is called. DoDiscard method calls \uldb OnDiscard\plain\fs24 {\v IBN5GA} event handler. Descendants can override this method to perform specific action.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoDiscard method directly, since it is called by TComDataPacket automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox}
{\up #}{\footnote\pard\plain{\up #} .QJN35}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComComboBox_Object,TComComboBox}
{\up K}{\footnote\pard\plain{\up K} TComComboBox}
\b\fs28\cf1 \{bml bm6.BMP\} TComComboBox\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 3LW9XH5}       \uldb Properties\plain\fs20 {\v 2E59JNP>props}       \uldb Methods\plain\fs20 {\v 1492H4K>props}
\par \pard TComComboBox is a windows combo box for selecting serial settings.\b 
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPortCtl
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par Drop TComComboBox control on the form to easily select common serial settings. TComComboBox can be linked to \uldb TCustomComPort\plain\fs20 {\v 1W4XK_N} descendand to to apply the desired settings to serial port.
\par \page
{\up #}{\footnote\pard\plain{\up #} 3LW9XH5}
\pard \b\fs24 Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TControl
\par        |
\par TWinControl
\par        |
\par TCustomComboBox
\par        |
\par TComComboBox
\par \page
{\up #}{\footnote\pard\plain{\up #} 2E59JNP}
\pard\keepn \b\cf1 TComComboBox properties\plain\fs24 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComComboBox
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb AutoApply\plain\fs20 {\v 182J6RA>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ComPort\plain\fs20 {\v FDEKYR>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ComProperty\plain\fs20 {\v OYELX8>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 1492H4K}
\pard\keepn \b\fs24\cf1 TComComboBox methods\plain\fs24 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \fs16 
\par \b\fs20 In TComComboBox
\par \plain\fs20 \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Change\plain\fs20 {\v 14W.YNN>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb UpdateSettings\plain\fs20 {\v Y9DKD2>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ApplySettings\plain\fs20 {\v 4_L..D9>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 2DHXL4C>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v 1.JINVW>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Notification\plain\fs20 {\v 4PAV_M5>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.Create}
{\up #}{\footnote\pard\plain{\up #} 2DHXL4C}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComComboBox_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComComboBox;TComComboBox,Create}
\b\fs28\cf1 TComComboBox.Create\plain\fs20 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Creates an instance of TComComboBox control.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(AOwner: TComponent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Create to programatically create TComComboBox object. TComComboBox control that is put on a form is automatically created.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.AutoApply}
{\up #}{\footnote\pard\plain{\up #} 182J6RA}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AutoApply;AutoApply_Property;TComComboBox_AutoApply}
{\up K}{\footnote\pard\plain{\up K} AutoApply;AutoApply,TComComboBox;TComComboBox,AutoApply}
\b\fs28\cf1 TComComboBox.AutoApply\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Specifies whether changes are automaticaly applied.
\par \fs16 
\par \b\fs24 property\plain\fs24  AutoApply: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 If AutoApply is True and \uldb ComPort\plain\fs24 {\v FDEKYR} property is not nil, changes are automatically applied when selection in combo box is changed.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 If \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component changes property that is shown in combo box, the selection in combo box is not automatically updated. The application must call \uldb UpdateSettings\plain\fs24 {\v Y9DKD2} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.ComPort}
{\up #}{\footnote\pard\plain{\up #} FDEKYR}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComComboBox_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComComboBox;TComComboBox,ComPort}
\b\fs28\cf1 TComComboBox.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Specifies the TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ComPort property to link TComComboBox control with \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component for applying and updating changes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.ComProperty}
{\up #}{\footnote\pard\plain{\up #} OYELX8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComProperty;ComProperty_Property;TComComboBox_ComProperty}
{\up K}{\footnote\pard\plain{\up K} ComProperty;ComProperty,TComComboBox;TComComboBox,ComProperty;TComProperty type}
\b\fs28\cf1 TComComboBox.ComProperty\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Selects serial setting.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComProperty = (cpNone, cpPortNum, cpBaudRate, cpDataBits, cpStopBits, cpParity, cpFlowControl);
\par \b property\plain\fs24  ComProperty: TComProperty;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ComProperty property to select which \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} property is shown in combo box. ComProperty can be one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 \fs20 cpNone\tab \tab No property is shown in combo box
\par cpPortNum\tab \tab PortNum property is shown in combo box
\par cpBaudRate\tab \tab BaudRate property
\par cpDataBits\tab \tab DataBits property
\par cpStopBits\tab \tab StopBits property
\par cpParity\tab \tab Parity.Bits property
\par cpFlowControl\tab \tab FlowControl.FlowControl property
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.Destroy}
{\up #}{\footnote\pard\plain{\up #} 1.JINVW}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Destroy;Destroy_Method;TComComboBox_Destroy}
{\up K}{\footnote\pard\plain{\up K} Destroy;Destroy,TComComboBox;TComComboBox,Destroy}
\b\fs28\cf1 TComComboBox.Destroy\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Destroys an instance of TComComboBox control.
\par \fs16 
\par \b\fs24 destructor\plain\fs24  Destroy; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TComComboBox control is not already freed, and only then calls Destroy.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.UpdateSettings}
{\up #}{\footnote\pard\plain{\up #} Y9DKD2}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComComboBox_UpdateSettings;UpdateSettings;UpdateSettings_Method}
{\up K}{\footnote\pard\plain{\up K} TComComboBox,UpdateSettings;UpdateSettings;UpdateSettings,TComComboBox}
\b\fs28\cf1 TComComboBox.UpdateSettings\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Updates selection in combo box.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  UpdateSettings;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call UpdateSettings method to update selection in combo box to show the correct state of \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} setting. If \uldb ComPort\plain\fs24 {\v FDEKYR} property is nil, the method has no effect.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.ApplySettings}
{\up #}{\footnote\pard\plain{\up #} 4_L..D9}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ApplySettings;ApplySettings_Method;TComComboBox_ApplySettings}
{\up K}{\footnote\pard\plain{\up K} ApplySettings;ApplySettings,TComComboBox;TComComboBox,ApplySettings}
\b\fs28\cf1 TComComboBox.ApplySettings\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Applies settings to TCustomComPort component.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ApplySettings;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call ApplySettings method to apply current selection in combo box to linked \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component. If \uldb ComPort\plain\fs24 {\v FDEKYR} property is nil, the method has no effect.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 If \uldb AutoApply\plain\fs24 {\v 182J6RA} is True, selection is automatically applied when selection changes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.Change}
{\up #}{\footnote\pard\plain{\up #} 14W.YNN}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Change;Change_Method;TComComboBox_Change}
{\up K}{\footnote\pard\plain{\up K} Change;Change,TComComboBox;TComComboBox,Change}
\b\fs28\cf1 TComComboBox.Change\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Applies settings if allowed.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Change; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Change method is called automatically when user current selection is changed in combo box. If \uldb AutoApply\plain\fs24 {\v 182J6RA} is True and \uldb ComPort\plain\fs24 {\v FDEKYR} is not nil, changes are applied to linked TCustomComPort component. Change then calls OnChange event.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComComboBox.Notification}
{\up #}{\footnote\pard\plain{\up #} 4PAV_M5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Notification;Notification_Method;TComComboBox_Notification}
{\up K}{\footnote\pard\plain{\up K} Notification;Notification,TComComboBox;TComComboBox,Notification}
\b\fs28\cf1 TComComboBox.Notification\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComComboBox\plain\fs20 {\v .QJN35>main}
\par \pard \fs24 Responds to notifications when objects are about to be created or destroyed.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Notification(AComponent: TComponent; Operation: TOperation); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Notification is called automatically when components are created or destroyed. After calling the inherited method, Notification checks whether the \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component specified by the \uldb ComPort\plain\fs24 {\v FDEKYR} property is about to be destroyed. If the component is being destroyed, Notification sets the ComPort property to nil.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup}
{\up #}{\footnote\pard\plain{\up #} IJ98UG}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComRadioGroup_Object,TComRadioGroup}
{\up K}{\footnote\pard\plain{\up K} TComRadioGroup}
\b\fs28\cf1 \{bml bm7.BMP\} TComRadioGroup\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 9QPJVS}       \uldb Properties\plain\fs20 {\v 9X_G_J>props}       \uldb Methods\plain\fs20 {\v 23KZ4XP>props}
\par \pard TComRadioGroup is a group of radio buttons for selecting serial settings.\b 
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPortCtl
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par Drop TComRadioGroup control on the form to easily select common serial settings. TComRadioGroup can be linked to \uldb TCustomComPort\plain\fs20 {\v 1W4XK_N} descendand to to apply the desired settings to serial port.
\par \page
{\up #}{\footnote\pard\plain{\up #} 9QPJVS}
\pard \b\fs24 Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TControl
\par        |
\par TWinControl
\par        |
\par TCustomControl
\par        |
\par TCustomGroupBox
\par        |
\par TCustomRadioGroup
\par        |
\par TComRadioGroup
\par \page
{\up #}{\footnote\pard\plain{\up #} 9X_G_J}
\pard\keepn \b\cf1 TComRadioGroup properties\plain\fs24 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComRadioGroup
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb AutoApply\plain\fs20 {\v FMNKBG>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ComPort\plain\fs20 {\v 12KHT4N>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ComProperty\plain\fs20 {\v BQJPI4>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 23KZ4XP}
\pard\keepn \b\fs24\cf1 TComRadioGroup methods\plain\fs24 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \fs16 
\par \b\fs20 In TComRadioGroup
\par \plain\fs20 \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Click\plain\fs20 {\v 1RA80LP>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb UpdateSettings\plain\fs20 {\v 18KNQXK>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ApplySettings\plain\fs20 {\v ARAF_>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v JXKSGC>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v 1SQLW1S>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Notification\plain\fs20 {\v 1PQ6RON>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.Create}
{\up #}{\footnote\pard\plain{\up #} JXKSGC}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComRadioGroup_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComRadioGroup;TComRadioGroup,Create}
\b\fs28\cf1 TComRadioGroup.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Creates an instance of TComRadioGroup control.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(AOwner: TComponent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Create to programatically create TComRadioGroup object. TComRadioGroup control that is put on a form is automatically created.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.AutoApply}
{\up #}{\footnote\pard\plain{\up #} FMNKBG}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AutoApply;AutoApply_Property;TComRadioGroup_AutoApply}
{\up K}{\footnote\pard\plain{\up K} AutoApply;AutoApply,TComRadioGroup;TComRadioGroup,AutoApply}
\b\fs28\cf1 TComRadioGroup.AutoApply\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Specifies whether changes are automaticaly applied.
\par \fs16 
\par \b\fs24 property\plain\fs24  AutoApply: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 If AutoApply is True and \uldb ComPort\plain\fs24 {\v 12KHT4N} property is not nil, changes are automatically applied when selection in combo box is changed.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 If \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component changes property that is shown in radio group, the selection in combo box is not automatically updated. The application must call \uldb UpdateSettings\plain\fs24 {\v 18KNQXK} method.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.ComPort}
{\up #}{\footnote\pard\plain{\up #} 12KHT4N}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComRadioGroup_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComRadioGroup;TComRadioGroup,ComPort}
\b\fs28\cf1 TComRadioGroup.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Specifies the TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ComPort property to link TComRadioGroup control with \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component for applying and updating changes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.ComProperty}
{\up #}{\footnote\pard\plain{\up #} BQJPI4}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComProperty;ComProperty_Property;TComRadioGroup_ComProperty}
{\up K}{\footnote\pard\plain{\up K} ComProperty;ComProperty,TComRadioGroup;TComProperty type;TComRadioGroup,ComProperty}
\b\fs28\cf1 TComRadioGroup.ComProperty\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Selects serial setting.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComProperty = (cpNone, cpPortNum, cpBaudRate, cpDataBits, cpStopBits, cpParity, cpFlowControl);
\par \b property\plain\fs24  ComProperty: TComProperty;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ComProperty property to select which \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} property is shown in radio group. ComProperty can be one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 \fs20 cpNone\tab \tab No property is shown in radio group
\par cpPortNum\tab \tab PortNum property is shown in radio group
\par cpBaudRate\tab \tab BaudRate property
\par cpDataBits\tab \tab DataBits property
\par cpStopBits\tab \tab StopBits property
\par cpParity\tab \tab Parity.Bits property
\par cpFlowControl\tab \tab FlowControl.FlowControl property
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.Destroy}
{\up #}{\footnote\pard\plain{\up #} 1SQLW1S}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Destroy;Destroy_Method;TComRadioGroup_Destroy}
{\up K}{\footnote\pard\plain{\up K} Destroy;Destroy,TComRadioGroup;TComRadioGroup,Destroy}
\b\fs28\cf1 TComRadioGroup.Destroy\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Destroys an instance of TComRadioGroup control.
\par \fs16 
\par \b\fs24 destructor\plain\fs24  Destroy; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TComRadioGroup control is not already freed, and only then calls Destroy.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.UpdateSettings}
{\up #}{\footnote\pard\plain{\up #} 18KNQXK}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComRadioGroup_UpdateSettings;UpdateSettings;UpdateSettings_Method}
{\up K}{\footnote\pard\plain{\up K} TComRadioGroup,UpdateSettings;UpdateSettings;UpdateSettings,TComRadioGroup}
\b\fs28\cf1 TComRadioGroup.UpdateSettings\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Updates selection in radio group.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  UpdateSettings;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call UpdateSettings method to update selection in radio group to show the correct state of \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} setting. If \uldb ComPort\plain\fs24 {\v 12KHT4N} property is nil, the method has no effect.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.ApplySettings}
{\up #}{\footnote\pard\plain{\up #} ARAF_}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ApplySettings;ApplySettings_Method;TComRadioGroup_ApplySettings}
{\up K}{\footnote\pard\plain{\up K} ApplySettings;ApplySettings,TComRadioGroup;TComRadioGroup,ApplySettings}
\b\fs28\cf1 TComRadioGroup.ApplySettings\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Applies settings to TCustomComPort component.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ApplySettings;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call ApplySettings method to apply current selection in radio group to linked \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component. If \uldb ComPort\plain\fs24 {\v 12KHT4N} property is nil, the method has no effect.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 If \uldb AutoApply\plain\fs24 {\v FMNKBG} is True, selection is automatically applied when selection changes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.Change}
{\up #}{\footnote\pard\plain{\up #} 1RA80LP}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Change;Change_Method;TComRadioGroup_Change}
{\up K}{\footnote\pard\plain{\up K} Change;Change,TComRadioGroup;TComRadioGroup,Change}
\b\fs28\cf1 TComRadioGroup.Click\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Applies settings if allowed.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Click; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Change method is called automatically when user clicks in radio group control. If \uldb AutoApply\plain\fs24 {\v FMNKBG} is True and \uldb ComPort\plain\fs24 {\v 12KHT4N} is not nil, changes are applied to linked TCustomComPort component. Click then calls OnClick event.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComRadioGroup.Notification}
{\up #}{\footnote\pard\plain{\up #} 1PQ6RON}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Notification;Notification_Method;TComRadioGroup_Notification}
{\up K}{\footnote\pard\plain{\up K} Notification;Notification,TComRadioGroup;TComRadioGroup,Notification}
\b\fs28\cf1 TComRadioGroup.Notification\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Responds to notifications when objects are about to be created or destroyed.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Notification(AComponent: TComponent; Operation: TOperation); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Notification is called automatically when components are created or destroyed. After calling the inherited method, Notification checks whether the \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component specified by the \uldb ComPort\plain\fs24 {\v 12KHT4N} property is about to be destroyed. If the component is being destroyed, Notification sets the ComPort property to nil.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed}
\pard\keepn {\up #}{\footnote\pard\plain{\up #} 8FKSTO}
{\up A}{\footnote\pard\plain{\up A} TComLed_Object,TComLed}
{\up K}{\footnote\pard\plain{\up K} TComLed}
\b\fs28\cf1 \{bml bm8.BMP\} TComLed\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 1.B2CP}       \uldb Properties\plain\fs20 {\v MH9UYU>props}       \uldb Methods\plain\fs20 {\v QGQHQU>props}       \uldb Events\plain\fs20 {\v 5FPV.UR>props}
\par \pard TComLed is a led indicator for serial signals.\b 
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPortCtl
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use TComLed control to easily show the state of CTS, DSR, RLSD, Ring, Tx and Rx signals. Application can provide custom bitmaps to show the state of signals. TComLed can be linked to \uldb TCustomComPort\plain\fs20 {\v 1W4XK_N} component to automatically update the control when signal(s) change.
\par \page
{\up #}{\footnote\pard\plain{\up #} 1.B2CP}
\pard \b Hierarchy\plain\fs20 
\par \fs16 
\par \fs20 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TControl
\par        |
\par TGraphicControl
\par        |
\par TComLed
\par \page
{\up #}{\footnote\pard\plain{\up #} MH9UYU}
\pard\keepn \b\fs24\cf1 TComLed properties\plain\fs24 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComLed
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ComPort\plain\fs20 {\v 123NKA2>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb GlyphOn\plain\fs20 {\v 9TPGF_>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb GlyphOff\plain\fs20 {\v 1N78KJ2>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Kind\plain\fs20 {\v 1339K5H>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb LedSignal\plain\fs20 {\v 1TKA_IV>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb State\plain\fs20 {\v GY8GFH>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb RingDuration\plain\fs20 {\v .9CCDU>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 5FPV.UR}
\pard\keepn \b\fs24\cf1 TComLed events\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TComLed\plain\fs20 {\v 8FKSTO>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs20 In TComLed
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnChange\plain\fs20 {\v 4P9EYME>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} QGQHQU}
\pard\keepn \b\fs24\cf1 TComLed methods\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TComLed\plain\fs20 {\v 8FKSTO>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs24 In TComLed\plain\fs24 
\par \fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v DS6CBT>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v CR0O0B>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoChange\plain\fs20 {\v UVJL7U>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Notification\plain\fs20 {\v 4_2T_U8>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb Paint\plain\fs20 {\v 1041NX.>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.ComPort}
{\up #}{\footnote\pard\plain{\up #} 123NKA2}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComLed_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComLed;TComLed,ComPort}
\b\fs28\cf1 TComLed.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Specifies the TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ComPort property to link TComLed control with \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component to show the status of \uldb LedSignal\plain\fs24 {\v 1TKA_IV} signal. If ComPort is not nil, the state of TComLed is automatically changed when signal on serial port changes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.LedSignal}
{\up #}{\footnote\pard\plain{\up #} 1TKA_IV}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} LedSignal;LedSignal_Property;TComLed_LedSignal}
{\up K}{\footnote\pard\plain{\up K} LedSignal;LedSignal,TComLed;TComLed,LedSignal;TComLedSignal type}
\b\fs28\cf1 TComLed.LedSignal\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Selects serial signal.
\par \fs16 
\par \b\fs24 type\plain\fs24  TComLedSignal = (lsConn, lsCTS, lsDSR, lsRLSD, lsRing, lsRx, lsTx);
\par \b property\plain\fs24  LedSignal: TComLedSignal;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set LedSignal property to select serial signal to be monitored. If \uldb ComPort\plain\fs24 {\v 123NKA2} is not nil, state of TComLed automatically changes to show the state of the selected signal. LedSignal can have one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\tab \tab Meaning
\par \pard\tx355 \plain\fs24 lsConn\tab \tab Serial port connected/disconnected
\par lsCTS\tab \tab CTS signal changed state
\par lsDSR\tab \tab DSR signal changed state
\par lsRLSD\tab RLSD signal changed state
\par lsRing\tab \tab Ring signal detected
\par lsRx\tab \tab Data recieve signal changed state
\par lsTx\tab \tab Data send signal changed state
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.GlyphOn}
{\up #}{\footnote\pard\plain{\up #} 9TPGF_}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} GlyphOn;GlyphOn_Property;TComLed_GlyphOn}
{\up K}{\footnote\pard\plain{\up K} GlyphOn;GlyphOn,TComLed;TComLed,GlyphOn}
\b\fs28\cf1 TComLed.GlyphOn\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Sets custom bitmap for \'93on\'94 state.
\par \fs16 
\par \b\fs24 property\plain\fs24  GlyphOn: TLedBitmap;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set GlyphOn bitmap to select the bitmap for \'93on\'94 state. This bitmap is shown when \uldb State\plain\fs24 {\v GY8GFH} has a value of lsOn.
\par \fs16 
\par \b\fs24 Note
\par \uldb \plain\uldb\fs24 Kind\plain\fs24 {\v 1339K5H} property must have a value of lkCustom.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.GlyphOff}
{\up #}{\footnote\pard\plain{\up #} 1N78KJ2}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} GlyphOff;GlyphOff_Property;TComLed_GlyphOff}
{\up K}{\footnote\pard\plain{\up K} GlyphOff;GlyphOff,TComLed;TComLed,GlyphOff}
\b\fs28\cf1 TComLed.GlyphOff\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Sets custom bitmap for \'93off\'94 state.
\par \fs16 
\par \b\fs24 property\plain\fs24  GlyphOn: TLedBitmap;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set GlyphOn bitmap to select the bitmap for \'93off\'94 state. This bitmap is shown when \uldb State\plain\fs24 {\v GY8GFH} has a value of lsOff.
\par \fs16 
\par \b\fs24 Note
\par \uldb \plain\uldb\fs24 Kind\plain\fs24 {\v 1339K5H} property must have a value of lkCustom.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.Kind}
{\up #}{\footnote\pard\plain{\up #} 1339K5H}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Kind;Kind_Property;TComLed_Kind}
{\up K}{\footnote\pard\plain{\up K} Kind;Kind,TComLed;TComLed,Kind;TLedKind type}
\b\fs28\cf1 TComLed.Kind\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Sets kind of TComLed bitmaps
\par \fs16 
\par \b\fs24 type \plain\fs24 TLedKind = (lkRedLight, lkGreenLight, lkBlueLight, lkYellowLight, lkPurpleLight, lkBulb, lkCustom);
\par \b property\plain\fs24  Kind: TLedKind;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set Kind property to select bitmaps to show the state of serial port signals. There are six predefined pairs of bitmaps. Kind property can have one of the following value.
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 lsRedLight\tab \tab A red light is shown
\par lsBlueLight\tab \tab A blue light.
\par lsGreenLight\tab \tab A green light.
\par lsYellowLight\tab \tab A yellow light.
\par lsPurpleLight\tab \tab A purple light
\par lsBulb\tab \tab \tab A bulb is shown.
\par lsCustom\tab \tab Bitmaps are provided through \uldb GlyphOn\plain\fs24 {\v 9TPGF_}, \uldb GlyphOff\plain\fs24 {\v 1N78KJ2} properties.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.State}
{\up #}{\footnote\pard\plain{\up #} GY8GFH}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} State;State_Property;TComLed_State}
{\up K}{\footnote\pard\plain{\up K} State;State,TComLed;TComLed,State;TLedState type}
\b\fs28\cf1 TComLed.State\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Sets TComLed state.
\par \fs16 
\par \b\fs24 type\plain\fs24  TLedState = (lsOff, lsOn);
\par \b property\plain\fs24  State: TLedState;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set State property to change the state of TComLed.
\par \fs16 
\par \b\fs24 Note\plain\fs24 
\par It is invalid to change State property manually when \uldb ComPort\plain\fs24 {\v 123NKA2} is not nil.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.RingDuration}
{\up #}{\footnote\pard\plain{\up #} .9CCDU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} RingDuration;RingDuration_Property;TComLed_RingDuration}
{\up K}{\footnote\pard\plain{\up K} RingDuration;RingDuration,TComLed;TComLed,RingDuration}
\b\fs28\cf1 TComLed.RingDuration\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Sets duration of ring signal.
\par \fs16 
\par \b\fs24 property\plain\fs24  RingDuration: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Ring signal is treated slightly different than other signals. \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} does not report \'93on\'94 and \'93off\'94 state. It only reports the detection of Ring signal. At this point, \uldb State\plain\fs24 {\v GY8GFH} is set to lsOn and after RingDuration miliseconds it is set to lsOff.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.OnChange}
{\up #}{\footnote\pard\plain{\up #} 4P9EYME}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnChange;OnChange_Event;TComLed_OnChange}
{\up K}{\footnote\pard\plain{\up K} OnChange;OnChange,TComLed;TComLed,OnChange;TLedStateEvent type}
\b\fs28\cf1 TComLed.OnChange\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Occurs on state change.
\par \fs16 
\par \b\fs24 type\plain\fs24  TLedStateEvent = \b procedure\plain\fs24 (Sender: TObject; AState: TLedState) \b of object\plain\fs24 ;
\par \b property\plain\fs24  OnChange: TLedStateEvent;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 OnChange event is triggered when \uldb State\plain\fs24 {\v GY8GFH} property changes its value either manually or automatically AState parameter is a new value of State property..
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.Create}
{\up #}{\footnote\pard\plain{\up #} DS6CBT}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComLed_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComLed;TComLed,Create}
\b\fs28\cf1 TComLed.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Creates an instance of TComLed class.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(AOwner: TComponent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Create to programatically create TComLed object. ComLed components that are put on a form are automatically created.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.Destroy}
{\up #}{\footnote\pard\plain{\up #} CR0O0B}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Destroy;Destroy_Method;TComLed_Destroy}
{\up K}{\footnote\pard\plain{\up K} Destroy;Destroy,TComLed;TComLed,Destroy}
\b\fs28\cf1 TComLed.Destroy\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Destroys TComLed object.
\par \fs16 
\par \b\fs24 destructor\plain\fs24  Destroy; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TComLed component is not already freed, and only then calls Destroy.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.DoChange}
{\up #}{\footnote\pard\plain{\up #} UVJL7U}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoChange;DoChange_Method;TComLed_DoChange}
{\up K}{\footnote\pard\plain{\up K} DoChange;DoChange,TComLed;TComLed,DoChange}
\b\fs28\cf1 TComLed.DoChange\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComLed\plain\fs20 {\v 8FKSTO>main}
\par \pard \fs24 Calls OnChange event.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoChange(AState: TLedState); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 DoChange procedure is called when \uldb State\plain\fs24 {\v GY8GFH} property changes its value. Descendands can override this method to perform specific action on state change.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 Do not call DoChange method directly, since it is called by TComLed automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.Notification}
{\up #}{\footnote\pard\plain{\up #} 4_2T_U8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Notification;Notification_Method;TComLed_Notification}
{\up K}{\footnote\pard\plain{\up K} Notification;Notification,TComLed;TComLed,Notification}
\b\fs28\cf1 TComLed.Notification\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Responds to notifications when objects are about to be created or destroyed.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Notification(AComponent: TComponent; Operation: TOperation); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Notification is called automatically when components are created or destroyed. After calling the inherited method, Notification checks whether the \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component specified by the \uldb ComPort\plain\fs24 {\v 123NKA2} property is about to be destroyed. If the component is being destroyed, Notification sets the ComPort property to nil.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComLed.Paint}
{\up #}{\footnote\pard\plain{\up #} 1041NX.}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Paint;Paint_Method;TComLed_Paint}
{\up K}{\footnote\pard\plain{\up K} Paint;Paint,TComLed;TComLed,Paint}
\b\fs28\cf1 TComLed.Paint\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComRadioGroup\plain\fs20 {\v IJ98UG>main}
\par \pard \fs24 Paints TComLed control.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Paint; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Paint method is called as a response to WM_PAINT message. It paints TComLed control. Descendands can override this method to add custom painting to the control.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTerminal}
{\up #}{\footnote\pard\plain{\up #} G3L022}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComTerminal_Object,TComTerminal}
{\up K}{\footnote\pard\plain{\up K} TComTerminal}
\b\fs28\cf1 \{bml bm9.BMP\} TComTerminal\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 4VZL_EK}       \uldb Properties\plain\fs20 {\v LN5O9G>props}       \uldb Methods\plain\fs20 {\v 1ODKL9N>props}       \uldb Events\plain\fs20 {\v 3_07HD2>props}
\par \pard TComTerminal is a VT52/VT100/ANSI terminal control.\b 
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPortCtl
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 TComTerminal control recieves data from \uldb TCustomComPort\plain\fs20 {\v 1W4XK_N} component and puts it on the screen. The control supports connection to VT52, VT100 and ANSI terminal servers. Application can also provide custom escape code parsing in \uldb OnGetEscapeCodes\plain\fs20 {\v VWG_AQ} event.
\par \page
{\up #}{\footnote\pard\plain{\up #} 4VZL_EK}
\pard \b Hierarchy\plain\fs20 
\par \fs16 
\par \fs20 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TControl
\par        |
\par TWinControl
\par        |
\par TCustomControl
\par        |
\par TCustomComTerminal
\par        |
\par TComTerminal
\par \page
{\up #}{\footnote\pard\plain{\up #} LN5O9G}
\pard\keepn \b\fs24\cf1 TComTerminal properties\plain\fs24 
\par \uldb \fs20 TComTerminal\plain\fs20 {\v G3L022>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 Derived from TCustomComTerminal
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb AltColor\plain\fs20 {\v 77LREZ>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb AppendLF\plain\fs20 {\v M60LNT>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ArrowKeys\plain\fs20 {\v 5Y34_6R>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb AutoSize\plain\fs20 {\v 1N3MTQI>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Caret\plain\fs20 {\v 1QDF6B.>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Color\plain\fs20 {\v B2.1HE>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Connected\plain\fs20 {\v DMNBA4>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ComPort\plain\fs20 {\v 11TCGK.>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Columns\plain\fs20 {\v 1O1TE3K>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Emulation\plain\fs20 {\v 34RO98>main}
\par \pard \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Font\plain\fs20 {\v 3RDW8G5>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Force7Bit\plain\fs20 {\v 9NBORD>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb LocalEcho\plain\fs20 {\v 1KMSSXP>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb SendLF\plain\fs20 {\v 39GIMD>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Rows\plain\fs20 {\v 13K30HJ>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb WantTab\plain\fs20 {\v 3ODHWKH>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb WrapLines\plain\fs20 {\v 1_GXTW.>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 3_07HD2}
\pard\keepn \b\fs24\cf1 TComTerminal events\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TComTerminal\plain\fs20 {\v G3L022>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs20 Derived from TCustomComTerminal
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnChar\plain\fs20 {\v LKHLZ5>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnGetEscapeCodes\plain\fs20 {\v VWG_AQ>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnStrRecieved\plain\fs20 {\v JX13R>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OnUnhandledCode\plain\fs20 {\v VF9E3K>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 1ODKL9N}
\pard\keepn \b\fs24\cf1 TComTerminal methods\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TComTerminal\plain\fs20 {\v G3L022>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs24 Derived from TCustomComTerminal
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 12XVEY8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v CGZKDL>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb LoadFromStream\plain\fs20 {\v 12EUD0P>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb MoveCaret\plain\fs20 {\v 61HX.Y9>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteStr\plain\fs20 {\v 10RT5M>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteEscCode\plain\fs20 {\v LO_ZY5>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SaveToStream\plain\fs20 {\v 62G0G9>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SelectFont\plain\fs20 {\v 1FIZTCA>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ShowSetupDialog\plain\fs20 {\v KC_T1A>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal}
{\up #}{\footnote\pard\plain{\up #} ZHXVI6}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComTerminal_Object,TCustomComTerminal}
{\up K}{\footnote\pard\plain{\up K} TCustomComTerminal}
\b\fs28\cf1 TCustomComTerminal\plain\fs28 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v VDW4P9}       \uldb Properties\plain\fs20 {\v CONHGP>props}       \uldb Methods\plain\fs20 {\v 80EU_X>props}       \uldb Events\plain\fs20 {\v CPFRHA>props}
\par \pard TCustomComTerminal is a base class for client terminals.\b 
\par \plain\fs16 
\par \b\fs20 Unit
\par \plain\fs20 CPortCtl
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 TCustomComTerminal is a base class that provides interface for terminals. Do not create an instance of TCustomComTerminal. Use controls derived from TCustomComTerminal such as \uldb TComTerminal\plain\fs20 {\v G3L022}.
\par \page
{\up #}{\footnote\pard\plain{\up #} VDW4P9}
\pard \b Hierarchy\plain\fs20 
\par \fs16 
\par \fs20 TObject
\par        |
\par TPersistent
\par        |
\par TComponent
\par        |
\par TControl
\par        |
\par TWinControl
\par        |
\par TCustomControl
\par        |
\par TCustomComTerminal
\par \page
{\up #}{\footnote\pard\plain{\up #} CONHGP}
\pard\keepn \b\fs24\cf1 TCustomComTerminal properties\plain\fs24 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TCustomComTerminal
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb AltColor\plain\fs20 {\v 77LREZ>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb AppendLF\plain\fs20 {\v M60LNT>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ArrowKeys\plain\fs20 {\v 5Y34_6R>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb AutoSize\plain\fs20 {\v 1N3MTQI>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Caret\plain\fs20 {\v 1QDF6B.>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Color\plain\fs20 {\v B2.1HE>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Connected\plain\fs20 {\v DMNBA4>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ComPort\plain\fs20 {\v 11TCGK.>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Columns\plain\fs20 {\v 1O1TE3K>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Emulation\plain\fs20 {\v 34RO98>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Font\plain\fs20 {\v 3RDW8G5>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Force7Bit\plain\fs20 {\v 9NBORD>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb LocalEcho\plain\fs20 {\v 1KMSSXP>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SendLF\plain\fs20 {\v 39GIMD>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Rows\plain\fs20 {\v 13K30HJ>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WantTab\plain\fs20 {\v 3ODHWKH>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WrapLines\plain\fs20 {\v 1_GXTW.>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} CPFRHA}
\pard\keepn \b\fs24\cf1 TCustomComTerminal events\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs20 In TCustomComTerminal
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnChar\plain\fs20 {\v LKHLZ5>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnGetEscapeCodes\plain\fs20 {\v VWG_AQ>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnStrRecieved\plain\fs20 {\v JX13R>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb OnUnhandledCode\plain\fs20 {\v VF9E3K>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 80EU_X}
\pard\keepn \b\fs24\cf1 TCustomComTerminal methods\plain\b\fs24 
\par \uldb \plain\uldb\fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \b\fs16 
\par \fs24 In TCustomComTerminal
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 12XVEY8>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Destroy\plain\fs20 {\v CGZKDL>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoChar\plain\fs20 {\v ALHLZ5>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoGetEscapeCodes\plain\fs20 {\v 1UHW_A0>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoStrRecieved\plain\fs20 {\v 4L829MP>main}
\par \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb DoUnhandledCode\plain\fs20 {\v 1AGHEPD>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb LoadFromStream\plain\fs20 {\v 12EUD0P>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb MoveCaret\plain\fs20 {\v 61HX.Y9>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteStr\plain\fs20 {\v 10RT5M>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb WriteEscCode\plain\fs20 {\v LO_ZY5>main}
\par \pard \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SaveToStream\plain\fs20 {\v 62G0G9>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb SelectFont\plain\fs20 {\v 1FIZTCA>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb ShowSetupDialog\plain\fs20 {\v KC_T1A>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Connected}
{\up #}{\footnote\pard\plain{\up #} DMNBA4}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Connected;Connected_Property;TCustomComTerminal_Connected}
{\up K}{\footnote\pard\plain{\up K} Connected;Connected,TCustomComTerminal;TCustomComTerminal,Connected}
\b\fs28\cf1 TCustomComTerminal.Connected\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Indicates whether a connection is active.
\par \fs16 
\par \b\fs24 property\plain\fs24  Connected: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set Connected to True to open connection to terminal server. Set Connected to False close connection. An application can check Connected to determine whether or not a connection is active. If Connected is True, terminal is connected to server, otherwise it is disconnected.
\par \fs16 
\par \b\fs24 Note\plain\fs24 
\par If \uldb ComPort\plain\fs24 {\v 11TCGK.} property is nil, Connected is always false.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.AutoSize}
{\up #}{\footnote\pard\plain{\up #} 1N3MTQI}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AutoSize;AutoSize_Property;TCustomComTerminal_AutoSize}
{\up K}{\footnote\pard\plain{\up K} AutoSize;AutoSize,TCustomComTerminal;TCustomComTerminal,AutoSize}
\b\fs28\cf1 TCustomComTerminal.AutoApply\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Determines whether the size of control automatically changes to accomodate its context.
\par \fs16 
\par \b\fs24 property\plain\fs24  AutoSize: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use AutoSize to make the terminal control adjust its size automatically so the client area accommodates the screen. When AutoSize is False, the terminal control has a fixed height and width. When AutoSize is True, the size of the control is readjusted whenever a change occurs that could affect the size of the control, such as a change to the font or border style.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Color}
{\up #}{\footnote\pard\plain{\up #} B2.1HE}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Color;Color_Property;TCustomComTerminal_Color}
{\up K}{\footnote\pard\plain{\up K} Color;Color,TCustomComTerminal;TCustomComTerminal,Color}
\b\fs28\cf1 TCustomComTerminal.Color\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Specifies background color.
\par \fs16 
\par \b\fs24 property\plain\fs24  Color: TColor;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Color property to set background color of terminal screen. Default background color for terminals is black, but application can change the value to set custom background color.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.AltColor}
{\up #}{\footnote\pard\plain{\up #} 77LREZ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AltColor;AltColor_Property;TCustomComTerminal_AltColor}
{\up K}{\footnote\pard\plain{\up K} AltColor;AltColor,TCustomComTerminal;TCustomComTerminal,AltColor}
\b\fs28\cf1 TCustomComTerminal.AltColor\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Specifies alternativ font color.
\par \fs16 
\par \b\fs24 property\plain\fs24  AltColor: TColor;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use AltColor property to set alternative font color of terminal screen. Alternative font color is set automatically when terminal recieves escape code which requests alternativ color for current font.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Caret}
{\up #}{\footnote\pard\plain{\up #} 1QDF6B.}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Caret;Caret_Property;TCustomComTerminal_Caret}
{\up K}{\footnote\pard\plain{\up K} Caret;Caret,TCustomComTerminal;TCustomComTerminal,Caret;TTermCaret type}
\b\fs28\cf1 TCustomComTerminal.Caret\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Sets caret type.
\par \fs16 
\par \b\fs24 type\plain\fs24  TTermCaret = (tcBlock, tcUnderline, tcNone);
\par \b property\plain\fs24  Caret: TTermCaret;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Set Caret property to specify kind of caret terminal control uses. Caret or terminal cursor is visible only when terminal control has focus. Caret can have one of the following values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 tcBlock\tab \tab \tab Block style caret
\par tcUnderline\tab \tab Underline style caret
\par tcNone\tab \tab \tab No caret visible
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.ComPort}
\pard\keepn {\up #}{\footnote\pard\plain{\up #} 11TCGK.}
{\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TCustomComTerminal_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TCustomComTerminal;TCustomComTerminal,ComPort}
\b\fs28\cf1 TCustomComTerminal.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Specifies the TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ComPort property to link TCustomComTerminal component with \uldb TCustomComPort\plain\fs24 {\v 1W4XK_N} component. The component gets all data from ComPort component. More than one TComTerminal control can have the same ComPort component linked.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Font}
{\up #}{\footnote\pard\plain{\up #} 3RDW8G5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Font;Font_Property;TCustomComTerminal_Font}
{\up K}{\footnote\pard\plain{\up K} Font;Font,TCustomComTerminal;TCustomComTerminal,Font}
\b\fs28\cf1 TCustomComTerminal.Font\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Specifies terminal font.
\par \fs16 
\par \b\fs24 property\plain\fs24  Font: TFont;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Font property to set terminal font. TCustomComTerminal can use only fonts which have fixed pitch size. If selected font does not match terminal requirements, default terminal font is selected instead.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Emulation}
{\up #}{\footnote\pard\plain{\up #} 34RO98}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Emulation;Emulation_Property;TCustomComTerminal_Emulation}
{\up K}{\footnote\pard\plain{\up K} Emulation;Emulation,TCustomComTerminal;TCustomComTerminal,Emulation;TTermEmulation type}
\b\fs28\cf1 TCustomComTerminal.Emulation\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Specifies emulation type.
\par \fs16 
\par \b\fs24 type\plain\fs24  TTermEmulation = (teVT100orANSI, teVT52, teNone);
\par \b property\plain\fs24  Emulation: TTermEmulation;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Set Emulation property to define how escape codes are interpreted. Most of terminal servers are VT100/ANSI compatible. If Emulation has a value of teNone, application can provide custom escape code handling in \uldb OnGetEscapeCodes\plain\fs24 {\v VWG_AQ} event handler. Emulation property can have one of the following values:
\par \pard \fs16 
\par \pard\brdrb\brdrs\tx355 \fs24 Value\tab \tab \tab Meaning
\par \pard\tx355 teVT100orANSI\tab VT100/ANSI compatible escape codes
\par teVT52\tab \tab \tab VT52 compatible escape codes
\par teNone\tab \tab \tab Do not interpret escape codes
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Columns}
{\up #}{\footnote\pard\plain{\up #} 1O1TE3K}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Columns;Columns_Property;TCustomComTerminal_Columns}
{\up K}{\footnote\pard\plain{\up K} Columns;Columns,TCustomComTerminal;TCustomComTerminal,Columns}
\b\fs28\cf1 TCustomComTerminal.Columns\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Specifies the number of columns.
\par \fs16 
\par \b\fs24 property\plain\fs24  Columns: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Columns property to set the number of columns of terminal screen. The default value for terminals is 80.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Rows}
{\up #}{\footnote\pard\plain{\up #} 13K30HJ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Rows;Rows_Property;TCustomComTerminal_Rows}
{\up K}{\footnote\pard\plain{\up K} Rows;Rows,TCustomComTerminal;TCustomComTerminal,Rows}
\b\fs28\cf1 TCustomComTerminal.Rows\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Specifies the number of rows.
\par \fs16 
\par \b\fs24 property\plain\fs24  Rows: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Rows property to set the number of rows of terminal screen. The default value for terminals is 24.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.ArrowKeys}
{\up #}{\footnote\pard\plain{\up #} 5Y34_6R}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ArrowKeys;ArrowKeys_Property;TCustomComTerminal_ArrowKeys}
{\up K}{\footnote\pard\plain{\up K} ArrowKeys;ArrowKeys,TCustomComTerminal;TArrowKeys type;TCustomComTerminal,ArrowKeys}
\b\fs28\cf1 TCustomComTerminal.ArrowKeys\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Defines cursor keys role.
\par \fs16 
\par \b\fs24 type\plain\fs24  TArrowKeys = (akTerminal, akWindows);
\par \b property\plain\fs24  ArrowKeys: TArrowKeys;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Set ArrowKeys property to define how control reacts to cursor key when pressed. ArrowKeys can have a value of:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\tab \tab \tab Meaning
\par \pard\tx355 \plain\fs24 akTerminal\tab \tab Cursor keys act as terminal keys. Escape code is 
\par \pard\li1415\fi705\tx355 sent to server when cursor key is pressed.
\par \pard\tx355 akWindows\tab \tab Cursor keys act as windows keys.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.LocalEcho}
{\up #}{\footnote\pard\plain{\up #} 1KMSSXP}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} LocalEcho;LocalEcho_Property;TCustomComTerminal_LocalEcho}
{\up K}{\footnote\pard\plain{\up K} LocalEcho;LocalEcho,TCustomComTerminal;TCustomComTerminal,LocalEcho}
\b\fs28\cf1 TCustomComTerminal.LocalEcho\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Enables or disables local echo.
\par \fs16 
\par \b\fs24 property\plain\fs24  LocalEcho: Boolean;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Use LocalEcho property to enable or disable local echo. If LocalEcho is True, all ascii charachters that are sent to server via terminal client are put on a screen. If LocalEcho is False local charachters are not echoed on screen.
\par \fs16 
\par \b\fs24 Note\plain\fs24 
\par It is recommended to set LocalEcho to True if terminal server does not return data to the client which had sent data.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.SendLF}
{\up #}{\footnote\pard\plain{\up #} 39GIMD}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SendLF;SendLF_Property;TCustomComTerminal_SendLF}
{\up K}{\footnote\pard\plain{\up K} SendLF;SendLF,TCustomComTerminal;TCustomComTerminal,SendLF}
\b\fs28\cf1 TCustomComTerminal.SendLF\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Enables or disables line feed sending.
\par \fs16 
\par \b\fs24 property\plain\fs24  SendLF: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use SendLF property to determine whether line feed charachter (ASCII code 10) is sent after each carriage return charachter (ASCII code 13). If SendLF is True, line feed is sent after carriage return. If SendLF is False, line feed is not sent after carriage return.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.AppendLF}
{\up #}{\footnote\pard\plain{\up #} M60LNT}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AppendLF;AppendLF_Property;TCustomComTerminal_AppendLF}
{\up K}{\footnote\pard\plain{\up K} AppendLF;AppendLF,TCustomComTerminal;TCustomComTerminal,AppendLF}
\b\fs28\cf1 TCustomComTerminal.AppendLF\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Enables or disables line feed appending.
\par \fs16 
\par \b\fs24 property\plain\fs24  AppendLF: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use AppendLF property to specify whether line feed charachter (ASCII code 10) is put after each recieved carriage return charachter (ASCII code 13). If AppendLF is True, line feed is appended to carriage return.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.WrapLines}
{\up #}{\footnote\pard\plain{\up #} 1_GXTW.}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComTerminal_WrapLines;WrapLines;WrapLines_Property}
{\up K}{\footnote\pard\plain{\up K} TCustomComTerminal,WrapLines;WrapLines;WrapLines,TCustomComTerminal}
\b\fs28\cf1 TCustomComTerminal.WrapLines\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Enables or disables line wrapping.
\par \fs16 
\par \b\fs24 property\plain\fs24  WrapLines: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use WrapLines property to specify whether line wrapping is used. If WrapLines is True, cursor is moved to the beging of the next line when it reaches end of current line. If WrapLines is False, charachters at the end of the line are overlapped.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.WantTab}
{\up #}{\footnote\pard\plain{\up #} 3ODHWKH}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComTerminal_WantTab;WantTab;WantTab_Property}
{\up K}{\footnote\pard\plain{\up K} TCustomComTerminal,WantTab;WantTab;WantTab,TCustomComTerminal}
\b\fs28\cf1 TCustomComTerminal.WantTab\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Enables or disables tab key processing.
\par \fs16 
\par \b\fs24 property\plain\fs24  WantTab: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use WantTab property to define Tab key behaviour. If WantTab is True, pressing Tab key sends Tab charachter to serial port using linked TCustomComPort component. If WantTab is False, pressing Tab key changes focus from terminal to next control on the form.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Force7Bit}
{\up #}{\footnote\pard\plain{\up #} 9NBORD}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Force7Bit;Force7Bit_Property;TCustomComTerminal_Force7Bit}
{\up K}{\footnote\pard\plain{\up K} Force7Bit;Force7Bit,TCustomComTerminal;TCustomComTerminal,Force7Bit}
\b\fs28\cf1 TCustomComTerminal.Force7Bit\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Determines whether 7 bit charachters are processed.
\par \fs16 
\par \b\fs24 property\plain\fs24  Force7Bit: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Force7Bit property to enable or disable 7 bit charachter processing. If Force7Bit  is True, all incoming charachters are processed as 7 bit charachters.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.OnChar}
{\up #}{\footnote\pard\plain{\up #} LKHLZ5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnChar;OnChar_Event;TCustomComTerminal_OnChar}
{\up K}{\footnote\pard\plain{\up K} OnChar;OnChar,TCustomComTerminal;TChScreenEvent;TCustomComTerminal,OnChar}
\b\fs28\cf1 TCustomComTerminal.OnChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Occurs when charachter is put on a screen.
\par \fs16 
\par \b\fs24 type\plain\fs24  TChScreenEvent = \b procedure\plain\fs24 (Sender: TObject; Ch: Char) \b of\plain\fs24  \b object\plain\fs24 ;
\par \b property\plain\fs24  OnChar: TChScreenEvent;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Write OnChar event to take specific action a non-escape code charachters is put on a screen. This is especially useful when application needs to log all incoming data to file or printer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.OnGetEscapeCodes}
{\up #}{\footnote\pard\plain{\up #} VWG_AQ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnGetEscapeCodes;OnGetEscapeCodes_Event;TCustomComTerminal_OnGetEscapeCodes}
{\up K}{\footnote\pard\plain{\up K} OnGetEscapeCodes;OnGetEscapeCodes,TCustomComTerminal;TCustomComTerminal,OnGetEscapeCodes;TEscapeEvent type}
\b\fs28\cf1 TCustomComTerminal.OnGetEscapeCodes\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Occurs when terminal needs escape codes definition.
\par \fs16 
\par \b\fs24 type \plain\fs24 TEscapeEvent = \b procedure\plain\fs24 (Sender: TObject; \b var\plain\fs24  EscapeCodes: TEscapeCodes) \b of object\plain\fs24 ;
\par \b property\plain\fs24  OnGetEscapeCodes: TEscapeEvent;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Write OnGetEscapeCodes event handler to provide custom escape code handling. If \uldb Emulation\plain\fs24 {\v 34RO98} is not teNone, OnGetEscapeCodes event handler is ignored. If Emulation is teNone and EscapeCodes parameter is nil, control does not process escape codes.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.OnStrRecieved}
{\up #}{\footnote\pard\plain{\up #} JX13R}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnStrRecieved;OnStrRecieved_Event;TCustomComTerminal_OnStrRecieved}
{\up K}{\footnote\pard\plain{\up K} OnStrRecieved;OnStrRecieved,TCustomComTerminal;TCustomComTerminal,OnStrRecieved;TStrRecvEvent}
\b\fs28\cf1 TCustomComTerminal.OnStrRecieved\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Occurs string is recieved from serial port.
\par \fs16 
\par \b\fs24 type\plain\fs24  TStrRecvEvent = \b procedure\plain\fs24 (Sender: TObject; \b var\plain\fs24  Str: string) \b of object\plain\fs24 ;
\par \b property\plain\fs24  OnStrRecieved: TStrRecvEvent;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Write OnStrRecieved event handler to take specific action when after string is read from input buffer of serial port. OnStrRecieved event is called before any escape code processing is done. OnStrRecieved event is a good place to modify recieved string before its processed.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.OnUnhandledCode}
{\up #}{\footnote\pard\plain{\up #} VF9E3K}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OnUnhandledCode;OnUnhandledCode_Event;TCustomComTerminal_OnUnhandledCode}
{\up K}{\footnote\pard\plain{\up K} OnUnhandledCode;OnUnhandledCode,TCustomComTerminal;TCustomComTerminal,OnUnhandledCode;TUnhandledEvent}
\b\fs28\cf1 TCustomComTerminal.OnUnhandledCode\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Occurs when escape code is not handled.
\par \fs16 
\par \b\fs24 type\plain\fs24  TUnhandledEvent\b  = procedure\plain\fs24 (Sender: TObject; Code: TEscapeCode; Data: \b string\plain\fs24 )\b  of object;
\par property\plain\fs24  OnUnhandledCode: TUnhandledEvent;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Write OnUnhandledCode event handler to take specific action when escape code has no default action or it is not recognized by selected emulation. Code parameter is the escape code value that has no default action or ecUnknown when it is not recognized. Data parameter is escape code as string type.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Create}
{\up #}{\footnote\pard\plain{\up #} 12XVEY8}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TCustomComTerminal_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TCustomComTerminal;TCustomComTerminal,Create}
\b\fs28\cf1 TCustomComTerminal.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Creates an instance of TCustomComTerminal control.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(AOwner: TComponent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Create to programatically create TCustomComTerminal object. TCustomComTerminal component that is put on a form is automatically created.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.Destroy}
{\up #}{\footnote\pard\plain{\up #} CGZKDL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Destroy;Destroy_Method;TCustomComTerminal_Destroy}
{\up K}{\footnote\pard\plain{\up K} Destroy;Destroy,TCustomComTerminal;TCustomComTerminal,Destroy}
\b\fs28\cf1 TCustomComTerminal.Destroy\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Destroys an instance of TCustomComTerminal control.
\par \fs16 
\par \b\fs24 destructor\plain\fs24  Destroy; \b override\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TCustomComTerminal component is not already freed, and only then calls Destroy.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.MoveCaret}
{\up #}{\footnote\pard\plain{\up #} 61HX.Y9}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} MoveCaret;MoveCaret_Method;TCustomComTerminal_MoveCaret}
{\up K}{\footnote\pard\plain{\up K} MoveCaret;MoveCaret,TCustomComTerminal;TCustomComTerminal,MoveCaret}
\b\fs28\cf1 TCustomComTerminal.MoveCaret\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Moves caret to new position.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  MoveCaret(AColumn, ARow: Integer);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call MoveCaret method to move caret to new position. AColumn is new column position and ARow is new row position. If AColumn or ARow parameter is out of bounds of terminal screen, caret is positioned at the edge of the screen.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.ShowSetupDialog}
{\up #}{\footnote\pard\plain{\up #} KC_T1A}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ShowSetupDialog;ShowSetupDialog_Method;TCustomComTerminal_ShowSetupDialog}
{\up K}{\footnote\pard\plain{\up K} ShowSetupDialog;ShowSetupDialog,TCustomComTerminal;TCustomComTerminal,ShowSetupDialog}
\b\fs28\cf1 TCustomComTerminal.ShowSetupDialog\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Shows terminal setup dialog.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  ShowSetupDialog;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Call ShowSetupDialog method to open a setup dialog for terminal. If users clicks OK button, changes are immidiately applied to terminal.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.SelectFont}
{\up #}{\footnote\pard\plain{\up #} 1FIZTCA}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SelectFont;SelectFont_Method;TCustomComTerminal_SelectFont}
{\up K}{\footnote\pard\plain{\up K} SelectFont;SelectFont,TCustomComTerminal;TCustomComTerminal,SelectFont}
\b\fs28\cf1 TCustomComTerminal.SelectFont\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Opens terminal font dialog box.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  SelectFont;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Call SelectMethod method to open a setup dialog for terminal font. Dialog allows only selection of fixed pitch size fonts.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.WriteStr}
{\up #}{\footnote\pard\plain{\up #} 10RT5M}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComTerminal_WriteStr;WriteStr;WriteStr_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComTerminal,WriteStr;WriteStr;WriteStr,TCustomComTerminal}
\b\fs28\cf1 TCustomComTerminal.WriteStr\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Puts string on screen.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  WriteStr(Str: \b string\plain\fs24 );
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call WriteStr method to put a string on screen. Method does not send data to serial port. Str parameter must not include escape codes, because terminal does not interrpret it when calling WriteStr method. If application needs to send escape code to terminal it should call \uldb WriteEscCode\plain\fs24 {\v LO_ZY5}.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.WriteEscCode}
{\up #}{\footnote\pard\plain{\up #} LO_ZY5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TCustomComTerminal_WriteEscCode;WriteEscCode;WriteEscCode_Method}
{\up K}{\footnote\pard\plain{\up K} TCustomComTerminal,WriteEscCode;WriteEscCode;WriteEscCode,TCustomComTerminal}
\b\fs28\cf1 TCustomComTerminal.WriteEscCode\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Sends escape code to terminal window.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  WriteEscCode(ACode: TEscapeCode; AParams: TParams);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call WriteEscCode method to send to escape code to terminal screen, but not to terminal server through serial port. ACode is escape code application needs to send and AParams are parameters specific to escape code sequence.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.LoadFromStream}
{\up #}{\footnote\pard\plain{\up #} 12EUD0P}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} LoadFromStream;LoadFromStream_Method;TCustomComTerminal_LoadFromStream}
{\up K}{\footnote\pard\plain{\up K} LoadFromStream;LoadFromStream,TCustomComTerminal;TCustomComTerminal,LoadFromStream}
\b\fs28\cf1 TCustomComTerminal.LoadFromStream\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Loads buffer from stream.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  LoadFromStream(Stream: TStream);
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Call LoadFromStream method to load screen buffer from a stream.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.SaveToStream}
{\up #}{\footnote\pard\plain{\up #} 62G0G9}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} SaveToStream;SaveToStream_Method;TCustomComTerminal_SaveToStream}
{\up K}{\footnote\pard\plain{\up K} SaveToStream;SaveToStream,TCustomComTerminal;TCustomComTerminal,SaveToStream}
\b\fs28\cf1 TCustomComTerminal.SaveToStream\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Saves screen buffer to stream.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  SaveToStream(Stream: TStream);
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Call SaveToStream method to save screen buffer to a stream.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 SaveToStream method does not save charachter atrributes, such as color, intensity, etc.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.DoChar}
{\up #}{\footnote\pard\plain{\up #} ALHLZ5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoChar;DoChar_Method;TCustomComTerminal_DoChar}
{\up K}{\footnote\pard\plain{\up K} DoChar;DoChar,TCustomComTerminal;TCustomComTerminal,DoChar}
\b\fs28\cf1 TCustomComTerminal.DoChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Calls OnChar event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoChar(Ch: Char); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 When non-escape charachter is put on terminal screen DoChar method is called. DoChar method calls \uldb OnChar\plain\fs24 {\v LKHLZ5} event handler. Application can override this method to take specific action when charachter is put on screen.
\par \fs16 
\par \b\fs24 Note\plain\fs24 
\par Do not call DoChar method directly since it is called by TCustomComTerminal automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.DoGetEscapeCodes}
{\up #}{\footnote\pard\plain{\up #} 1UHW_A0}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoGetEscapeCodes;DoGetEscapeCodes_Method;TCustomComTerminal_DoGetEscapeCodes}
{\up K}{\footnote\pard\plain{\up K} DoGetEscapeCodes;DoGetEscapeCodes,TCustomComTerminal;TCustomComTerminal,DoGetEscapeCodes}
\b\fs28\cf1 TCustomComTerminal.DoGetEscapeCodes\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Calls OnGetEscapeCodes.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoGetEscapeCodes(\b var\plain\fs24  EscapeCodes: TEscapeCodes); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 When TCustomComTerminal needs escape code processing class DoGetEscapeCodes method is called. DoGetEscapeCodes method calls \uldb OnGetEscapeCodes\plain\fs24 {\v 1UHW_A0} event handler. Application can override this method to take specific action when terminal needs custom escape code processing class.
\par \fs16 
\par \b\fs24 Note\plain\fs24 
\par Do not call DoGetEscapeCodes method directly since it is called by TCustomComTerminal automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.DoStrRecieved}
{\up #}{\footnote\pard\plain{\up #} 4L829MP}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoStrRecieved;DoStrRecieved_Method;TCustomComTerminal_DoStrRecieved}
{\up K}{\footnote\pard\plain{\up K} DoStrRecieved;DoStrRecieved,TCustomComTerminal;TCustomComTerminal,DoStrRecieved}
\b\fs28\cf1 TCustomComTerminal.DoStrRecieved\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Calls OnStrRecieved event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoStrRecieved(\b var\plain\fs24  Str: \b string\plain\fs24 ); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 When string is read out of input buffer DoStrRecieved method is called. DoStrRecieved method calls \uldb OnStrRecieved\plain\fs24 {\v JX13R} event handler. Application can override this method to take specific action when string is read out of input buffer.
\par \fs16 
\par \b\fs24 Note\plain\fs24 
\par Do not call DoStrRecieved method directly since it is called by TCustomComTerminal automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TCustomComTerminal.DoUnhandledCode}
{\up #}{\footnote\pard\plain{\up #} 1AGHEPD}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DoUnhandledCode;DoUnhandledCode_Method;TCustomComTerminal_DoUnhandledCode}
{\up K}{\footnote\pard\plain{\up K} DoUnhandledCode;DoUnhandledCode,TCustomComTerminal;TCustomComTerminal,DoUnhandledCode}
\b\fs28\cf1 TCustomComTerminal.DoUnhandledCode\plain\fs24 
\par \fs16 
\par \uldb \fs20 TCustomComTerminal\plain\fs20 {\v ZHXVI6>main}
\par \pard \fs24 Calls OnUnhandledCode event handler.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoUnhandledCode(Code: TEscapeCode; Data: \b string\plain\fs24 ); \b dynamic\plain\fs24 ;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 When terminal cannot interpret escape code DoUnhandledCode method is called. DoUnhandledCode method calls \uldb OnUnhandledCode\plain\fs24 {\v VF9E3K} event handler. Application can override this method to take specific action when escape code is unknown.
\par \fs16 
\par \b\fs24 Note\plain\fs24 
\par Do not call DoUnhandledCode method directly since it is called by TCustomComTerminal automatically.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts}
{\up #}{\footnote\pard\plain{\up #} 1N1MC_O}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComTimeouts;TComTimeouts_Object}
{\up K}{\footnote\pard\plain{\up K} TComTimeouts}
\b\fs28\cf1 TComTimeouts\plain\fs24 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 55NU0T}       \uldb Properties\plain\fs20 {\v 13GIJJ>props}       \uldb Methods\plain\fs20 {\v 2DPN6UE>props}
\par \pard \fs24 Defines timeouts for read and write operations.
\par \fs16 
\par \b\fs24 Unit
\par \plain\fs24 CPort
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Timeout property defines detailed timeout settings for read and write operations. When timeout for specific operation elapses, operation is aborted, however, no errors are reported.
\par \fs16 
\par \fs24 Two types of time-outs are enabled by the time-out parameters. An interval time-out occurs when the time between the receipt of any two characters exceeds a specified number of milliseconds. Timing starts when the first character is received and is restarted when each new character is received. A total time-out occurs when the total amount of time consumed by a read operation exceeds a calculated number of milliseconds. Timing starts immediately when the I/O operation begins. Write operations support only total time-outs. Read operations support both interval and total time-outs, which can be used separately or combined.
\par \pard \fs16 
\par \fs24 The time, in milliseconds, of the total time-out period for a read or write operation is calculated by using the multiplier and constant:
\par \fs16 
\par \fs24 Timeout = (MULTIPLIER * number_of_bytes) + CONSTANT
\par \page
{\up #}{\footnote\pard\plain{\up #} 55NU0T}
\pard \b Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TPersistent
\par        |
\par TComTimeouts
\par \page
{\up #}{\footnote\pard\plain{\up #} 13GIJJ}
\pard\keepn \b\cf1 TComTimeouts properties\plain\fs24 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComTimeouts
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb ComPort\plain\fs20 {\v 14A.SZ5>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ReadInterval\plain\fs20 {\v 3XCA_HJ>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ReadTotalConstant\plain\fs20 {\v IKBS5W>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ReadTotalMultiplier\plain\fs20 {\v KMHWV3>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb WriteTotalConstant\plain\fs20 {\v YUWG0P>main}\fs24 
\par \fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb WriteTotalMultiplier\plain\fs20 {\v LI2M5H>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 2DPN6UE}
\pard\keepn \b\fs24\cf1 TComTimeouts methods\plain\fs24 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \fs16 
\par \b\fs20 In TComTimeouts
\par \plain\fs20 \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb AssignTo\plain\fs20 {\v 4IKY_S7>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 19NU2V3>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.ComPort}
{\up #}{\footnote\pard\plain{\up #} 14A.SZ5}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComTimeouts_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComTimeouts;TComTimeouts,ComPort}
\b\fs28\cf1 TComTimeouts.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Determines TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use ComPort property to determine TCustomComPort component which this class belongs to.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.ReadInterval}
{\up #}{\footnote\pard\plain{\up #} 3XCA_HJ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ReadInterval;ReadInterval_Property;TComTimeouts_ReadInterval}
{\up K}{\footnote\pard\plain{\up K} ReadInterval;ReadInterval,TComTimeouts;TComTimeouts,ReadInterval}
\b\fs28\cf1 TComTimeouts.ReadInterval\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Specifies read interval timeout.
\par \fs16 
\par \b\fs24 property\plain\fs24  ReadInterval: Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Specifies the maximum time, in milliseconds, allowed to elapse between the arrival of two characters on the communications line. During a read operation, the time period begins when the first character is received. If the interval between the arrival of any two characters exceeds this amount, the read operation is completed and any buffered data is returned. A value of zero indicates that interval time-outs are not used. 
\par \pard \fs16 
\par \b\fs20 Note
\par \plain\fs24 A value of \b -1\plain\fs24 , combined with zero values for both the \uldb ReadTotalConstant\plain\fs24 {\v IKBS5W} and \uldb ReadTotalMultiplier\plain\fs24 {\v KMHWV3} properties, specifies that the read operation is to return immediately with the characters that have already been received, even if no characters have been received.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.ReadTotalConstant}
{\up #}{\footnote\pard\plain{\up #} IKBS5W}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ReadTotalConstant;ReadTotalConstant_Property;TComTimeouts_ReadTotalConstant}
{\up K}{\footnote\pard\plain{\up K} ReadTotalConstant;ReadTotalConstant,TComTimeouts;TComTimeouts,ReadTotalConstant}
\b\fs28\cf1 TComTimeouts.ReadTotalConstant\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Specifies constant for read total timeout.
\par \fs16 
\par \b\fs24 property\plain\fs24  ReadTotalConstant: Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Specifies the constant, in milliseconds, used to calculate the total time-out period for read operations. For each read operation, this value is added to the product of the \uldb ReadTotalMultiplier\plain\fs24 {\v KMHWV3} property and the requested number of bytes. 
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 A value of zero for both the \uldb ReadTotalMultiplier\plain\fs24 {\v KMHWV3} and ReadTotalConstant properties indicates that total time-outs are not used for read operations.
\par \pard \fs16 
\par \fs24 If an application sets \uldb ReadInterval\plain\fs24 {\v 3XCA_HJ} and \uldb ReadTotalMultiplier\plain\fs24 {\v KMHWV3} to \b -1\plain\fs24  and sets ReadTotalConstant to a value greater than zero, one of the following occurs when the read function is called:
\par \fs16 
\par \pard\li355\fi-355\tx355 \f1\fs18 \'b7\tab \plain\fs24 If there are any characters in the input buffer, read function returns immediately with the characters in the buffer.
\par \f1\fs18 \'b7\tab \plain\fs24 If there are no characters in the input buffer, read function waits until a character arrives and then returns immediately. 
\par \f1\fs18 \'b7\tab \plain\fs24 If no character arrives within the time specified by ReadTotalConstant, read function times out.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.ReadTotalMultiplier}
{\up #}{\footnote\pard\plain{\up #} KMHWV3}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ReadTotalMultiplier;TComTimeouts_ReadTotalMultiplier, ReadTotalMultiplier_Property}
{\up K}{\footnote\pard\plain{\up K} ReadTotalMultiplier;ReadTotalMultiplier,TComTimeouts;TComTimeouts,ReadTotalMultiplier}
\b\fs28\cf1 TComTimeouts.ReadTotalMultiplier\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Specifies multiplier for read total timeout.
\par \fs16 
\par \b\fs24 property\plain\fs24  ReadTotalMultiplier: Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Specifies the multiplier, in milliseconds, used to calculate the total time-out period for read operations. For each read operation, this value is multiplied by the requested number of bytes to be read.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 A value of zero for both ReadTotalTimeout the and \uldb ReadTotalConstant\plain\fs24 {\v IKBS5W} properties indicates that total time-outs are not used for read operations.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.WriteTotalConstant}
{\up #}{\footnote\pard\plain{\up #} YUWG0P}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComTimeouts_WriteTotalConstant;WriteTotalConstant;WriteTotalConstant_Property}
{\up K}{\footnote\pard\plain{\up K} TComTimeouts,WriteTotalConstant;WriteTotalConstant;WriteTotalConstant,TComTimeouts}
\b\fs28\cf1 TComTimeouts.WriteTotalConstant\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Specifies constant for write total timeout.
\par \fs16 
\par \b\fs24 property\plain\fs24  WriteTotalConstant: Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Specifies the constant, in milliseconds, used to calculate the total time-out period for write operations. For each write operation, this value is added to the product of the \uldb WriteTotalMultiplier\plain\fs24 {\v LI2M5H} properties and the number of bytes to be written.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 A value of zero for both the \uldb WriteTotalMultiplier\plain\fs24 {\v LI2M5H} and WriteTotalConstant properties indicates that total time-outs are not used for write operations.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.WriteTotalMultiplier}
{\up #}{\footnote\pard\plain{\up #} LI2M5H}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComTimeouts_WriteTotalMultiplier;WriteTotalMultiplier;WriteTotalMultiplier_Property}
{\up K}{\footnote\pard\plain{\up K} TComTimeouts,WriteTotalMultiplier;WriteTotalMultiplier;WriteTotalMultiplier,TComTimeouts}
\b\fs28\cf1 TComTimeouts.WriteTotalMultiplier\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Specifies multiplier for write total timeout.
\par \fs16 
\par \b\fs24 property\plain\fs24  WriteTotalMultiplier: Integer;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Specifies the multiplier, in milliseconds, used to calculate the total time-out period for write operations. For each write operation, this value is multiplied by the number of bytes to be written.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs24 A value of zero for both the WriteTotalMultiplier and \uldb WriteTotalConstant\plain\fs24 {\v YUWG0P} properties indicates that total time-outs are not used for write operations.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.Create}
{\up #}{\footnote\pard\plain{\up #} 19NU2V3}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComTimeouts_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComTimeouts;TComTimeouts,Create}
\b\fs28\cf1 TComTimeouts.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Creates an instance of TComTimeouts class.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  TComTimeouts.Create;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Use Create constructor to programmatically create an instance of TComTimeouts class. Create sets following properties to default values:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Property\plain\fs24 \tab \tab \tab \b Value\plain\fs24 
\par \pard\tx355 ReadInterval\tab \tab \tab -1
\par ReadTotalMultiplier\tab \tab 0
\par ReadTotalConstant\tab \tab 0
\par WriteTotalMultiplier\tab \tab 100
\par WriteTotalConstant\tab \tab 1000
\par \page
{\up $}{\footnote\pard\plain{\up $} TComTimeouts.AssignTo}
{\up #}{\footnote\pard\plain{\up #} 4IKY_S7}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AssignTo;AssignTo_Method;TComTimeouts_AssignTo}
{\up K}{\footnote\pard\plain{\up K} AssignTo;AssignTo,TComTimeouts;TComTimeouts,AssignTo}
\b\fs28\cf1 TComTimeouts.AssignTo\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComTimeouts\plain\fs20 {\v 1N1MC_O>main}
\par \pard \fs24 Handles assignments for TComTimeouts objects.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  AssignTo(Dest: TPersistent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par \fs24 Call AssignTo to copy the values of one TComTimeouts object to another.
\par \fs16 
\par \fs20 AssignTo overrides the inherited method in order to handle assignments specific to TComTimeouts objects.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl}
{\up #}{\footnote\pard\plain{\up #} 1_L_I7P}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComFlowControl;TComFlowControl_Object}
{\up K}{\footnote\pard\plain{\up K} TComFlowControl}
\b\fs28\cf1 TComFlowControl\plain\fs20 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v P9ZT1F}       \uldb Properties\plain\fs20 {\v 1FNHUW8>props}       \uldb Methods\plain\fs20 {\v HSQ87F>props}
\par \pard \fs24 Defines flow control settings.
\par \fs16 
\par \b\fs24 Unit
\par \plain\fs24 CPort
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 Flow control, sometimes called \'93handshaking\'94, is a concept that prevents buffer overflowing when the bytes are received faster than they are processed. There are basically two types of flow control, hardware and software.
\par \fs16 
\par \fs20 The most common settings for flow control are:
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs20 Flow control\plain\fs20 \tab \tab \tab \tab \b Values\plain\fs20 
\par \pard\tx355 RTS/CTS (Hardware)\tab \tab \tab ControlRTS := rtsHandshake;
\par \tab \tab \tab \tab \tab \tab OutCTSFlow := True;
\par Xon/Xoff (Software)\tab \tab \tab XonXoffOut := True;
\par \tab \tab \tab \tab \tab \tab XonXoffIn := True;
\par \page
{\up #}{\footnote\pard\plain{\up #} P9ZT1F}
\pard \b\fs24 Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TPersistent
\par        |
\par TComFlowControl
\par \page
{\up #}{\footnote\pard\plain{\up #} 1FNHUW8}
\pard\keepn \b\cf1 TComFlowControl properties
\par \uldb \plain\uldb\fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComFlowControl
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb ComPort\plain\fs20 {\v 1X5.2X4>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ControlDTR\plain\fs20 {\v AM7AV0>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ControlRTS\plain\fs20 {\v 13VCOBK>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb DSRSensitivity\plain\fs20 {\v YC3FUY>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb FlowControl\plain\fs20 {\v 11O1EO_>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OutCTSFlow\plain\fs20 {\v QCR6GL>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OutDSRFlow\plain\fs20 {\v 1PBR6GL>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb TxContinueOnXoff\plain\fs20 {\v _ZHDYB>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb XoffChar\plain\fs20 {\v 1ANWTE>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb XonChar\plain\fs20 {\v A8ORES>main}
\par \pard \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb XonXoffIn\plain\fs20 {\v _YZ4ME>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb XonXoffOut\plain\fs20 {\v 34FKZYV>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} HSQ87F}
\pard\keepn \b\cf1 TComFlowControl methods\plain\fs20 
\par \uldb TComFlowControl\plain\fs20 {\v 1_L_I7P>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \fs16 
\par \b\fs20 In TComFlowControl
\par \plain\fs20 \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb AssignTo\plain\fs20 {\v 2JGBS8D>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v PHKDN3>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.ComPort}
{\up #}{\footnote\pard\plain{\up #} 1X5.2X4}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComFlowControl_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComFlowControl;TComFlowControl,ComPort}
\b\fs28\cf1 TComFlowControl.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \fs24 Determines TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use ComPort property to determine TCustomComPort component which this class belongs to.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.ControlDTR}
{\up #}{\footnote\pard\plain{\up #} AM7AV0}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ControlDTR;ControlDTR_Property;TComFlowControl_ControlDTR}
{\up K}{\footnote\pard\plain{\up K} ControlDTR;ControlDTR,TComFlowControl;TComFlowControl,ControlDTR;TDTRFlowControl type}
\b\fs28\cf1 TComFlowControl.ControlDTR\plain\fs20\cf2 
\par \plain\fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \cf2 Specifies DTR flow control.
\par \fs16 
\par \b\fs24 type\plain\fs24\cf2  TDTRFlowControl = (dtrDisable, dtrEnable, dtrHandshake);
\par \b\fs20 property\plain\fs20\cf2  ControlDTR: TDTRFlowControl;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20\cf2 ControlDTR sets DTR (data-terminal-ready) flow control type.
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs20 Value\plain\fs20\cf2 \tab \tab \tab \b Meaning\plain\fs20\cf2 
\par \pard\tx355 dtrDisable\tab \tab Disables the DTR line when the device is 
\par  \tab \tab \tab \tab opened and leaves it disabled.
\par dtrEnable\tab \tab Enables the DTR line when the device is
\par  \tab \tab \tab \tab opened and leaves it on.
\par dtrHandshake\tab \tab Enables DTR handshaking. If handshaking is enabled,
\par  \tab \tab \tab \tab it is an error for the application to adjust the line
\par  \tab \tab \tab \tab by using the \uldb SetDTR\plain\fs20\cf2 {\v 2OD7Y7O} function
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.ControlRTS}
{\up #}{\footnote\pard\plain{\up #} 13VCOBK}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ControlRTS;ControlRTS_Property;TComFlowControl_ControlRTS}
{\up K}{\footnote\pard\plain{\up K} ControlRTS;ControlRTS,TComFlowControl;TComFlowControl,ControlRTS}
\b\fs28\cf1 TComFlowControl.ControlRTS\plain\fs20 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \cf2 Specifies RTS flow control.
\par \fs16 
\par \b\fs24 type\plain\fs24\cf2  TRTSFlowControl = (dtrDisable, dtrEnable, dtrHandshake, dtrToggle);
\par \b\fs20 property\plain\fs20\cf2  ControlRTS: TRTSFlowControl;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20\cf2 ControlRTS sets RTS (request-to-send) flow control type.
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs20 Value\plain\fs20\cf2 \tab \tab \tab \b Meaning\plain\fs20\cf2 
\par \pard\tx355 rrsDisable\tab \tab Disables the RTS line when the device is 
\par  \tab \tab \tab \tab opened and leaves it disabled.
\par rtsEnable\tab \tab Enables the RTS line when the device is
\par  \tab \tab \tab \tab opened and leaves it on.
\par \plain\fs20 rtsHandshake\tab \tab Enables RTS handshaking. The driver raises
\par  \tab \tab \tab \tab the RTS line when the "type-ahead" (input) buffer
\par  \tab \tab \tab \tab is less than one-half full and lowers the RTS line
\par  \tab \tab \tab \tab when the buffer is more than three-quarters full.
\par  \tab \tab \tab \tab If handshaking is enabled, it is an error for the application
\par \pard\tx355  \tab \tab \tab \tab to adjust the line by using the \uldb SetRTS\plain\fs20 {\v 2OD8.7P} function.
\par rtsToggle\tab \tab Specifies that the RTS line will be high if bytes are
\par  \tab \tab \tab \tab available for transmission. After all buffered bytes 
\par  \tab \tab \tab \tab have been sent, the RTS line will be low.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.DSRSensitivity}
{\up #}{\footnote\pard\plain{\up #} YC3FUY}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} DSRSensitivity;DSRSensitivity_Property;TComFlowControl_DSRSensitivity}
{\up K}{\footnote\pard\plain{\up K} DSRSensitivity;DSRSensitivity,TComFlowControl;TComFlowControl,DSRSensitivity}
\b\fs28\cf1 TComFlowControl.DSRSensitivity\plain\fs20 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard Enables or disables DSR sensitivity.
\par \fs16 
\par \b\fs20 property\plain\fs20  DSRSensitivity: Boolean;
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par Specifies whether the communications driver is sensitive to the state of the DSR signal. If this property is True, the driver ignores any bytes received, unless the DSR input line is high.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.FlowControl}
{\up #}{\footnote\pard\plain{\up #} 11O1EO_}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} FlowControl;FlowControl_Property;TComFlowControl_FlowControl}
{\up K}{\footnote\pard\plain{\up K} FlowControl;FlowControl,TComFlowControl;TComFlowControl,FlowControl;TFlowControl type}
\b\fs28\cf1 TComFlowControl.FlowControl\plain\fs20 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard Sets common flow control type.
\par \fs16 
\par \b\fs24\cf2 type\plain\fs24\cf2  TFlowControl = (fcHardware, fcSoftware, fcNone, fcCustom);
\par \plain\b\fs20 property\plain\fs20  FlowControl: TFlowControl;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Set FlowControl property to set one of common flow control types (e.g. hardware, software). FlowControl property is virtual property, so its value depends on the following properties: \uldb ControlRTS\plain\fs20 {\v 13VCOBK}, \uldb OutCTSFlow\plain\fs20 {\v QCR6GL}, \uldb XonXoffIn\plain\fs20 {\v _YZ4ME} and \uldb XonXoffOut\plain\fs20 {\v 34FKZYV}.
\par \fs16 
\par \b\fs20 Note
\par \plain\fs20 Setting FlowControl property usually changes other properties of \uldb TComFlowControl\plain\fs20 {\v 1_L_I7P} class. Also setting other properties of TComFlowControl class changes FlowControl property.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.OutCTSFlow}
{\up #}{\footnote\pard\plain{\up #} QCR6GL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OutCTSFlow;OutCTSFlow_Property;TComFlowControl_OutCTSFlow}
{\up K}{\footnote\pard\plain{\up K} OutCTSFlow;OutCTSFlow,TComFlowControl;TComFlowControl,OutCTSFlow}
\b\fs28\cf1 TComFlowControl.OutCTSFlow\plain\fs20 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard Enables or disables CTS signal monitoring.
\par \fs16 
\par \b\fs20 property\plain\fs20  OutCTSFlow: Boolean;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Specifies whether the CTS (clear-to-send) signal is monitored for output flow control. If this property is True and CTS is turned off, output is suspended until CTS is sent again.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.OutDSRFlow}
{\up #}{\footnote\pard\plain{\up #} 1PBR6GL}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OutDSRFlow;OutDSRFlow_Property;TComFlowControl_OutDSRFlow}
{\up K}{\footnote\pard\plain{\up K} OutDSRFlow;OutDSRFlow,TComFlowControl;TComFlowControl,OutDSRFlow}
\b\fs28\cf1 TComFlowControl.OutDSRFlow\plain\fs20 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard Enables or disables DSR signal monitoring.
\par \fs16 
\par \b\fs20 property\plain\fs20  OutDSRFlow: Boolean;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Specifies whether the DSR (data-set-ready) signal is monitored for output flow control. If this property is True and DSR is turned off, output is suspended until DSR is sent again.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.TxContinueOnXoff}
{\up #}{\footnote\pard\plain{\up #} _ZHDYB}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComFlowControl_TxContinueOnXoff;TxContinueOnXoff;TxContinueOnXoff_Property}
{\up K}{\footnote\pard\plain{\up K} TComFlowControl,TxContinueOnXoff;TxContinueOnXoff;TxContinueOnXoff,TComFlowControl}
\b\fs28\cf1 TComFlowControl.TxContinueOnXoff\plain\fs20 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard Enables or disables transmission after Xoff charachter has been received.
\par \fs16 
\par \b\fs24 property\plain\fs24  TxContinueOnXoff: Boolean;
\par \fs16 
\par \b\fs24 Description\plain\fs24 
\par Specifies whether transmission stops when the input buffer is full and the driver has transmitted the XoffChar character. If this property is True, transmission continues after the driver has transmitted the XoffChar character to stop receiving bytes. If this property is False, transmission does not continue until the driver has transmitted the XonChar character to resume reception.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.XoffChar}
{\up #}{\footnote\pard\plain{\up #} 1ANWTE}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComFlowControl_XoffChar;XoffChar;XoffChar_Property}
{\up K}{\footnote\pard\plain{\up K} TComFlowControl,XoffChar;XoffChar;XoffChar,TComFlowControl}
\b\fs28\cf1 TComFlowControl.XoffChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \fs24 Specifies the value of the Xoff charachter.
\par \fs16 
\par \b\fs24 property\plain\fs24  XoffChar: Char;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Specifies the value of the Xoff character for both transmission and reception. This is usally charachter of ASCII code 19.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.XonChar}
{\up #}{\footnote\pard\plain{\up #} A8ORES}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComFlowControl_XonChar;XonChar;XonChar_Property}
{\up K}{\footnote\pard\plain{\up K} TComFlowControl,XonChar;XonChar;XonChar,TComFlowControl}
\b\fs28\cf1 TComFlowControl.XonChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \fs24 Specifies the value of the Xon charachter.
\par \fs16 
\par \b\fs24 property\plain\fs24  XonChar: Char;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Specifies the value of the Xon character for both transmission and reception. This is usally charachter of ASCII code 17.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.XonXoffIn}
{\up #}{\footnote\pard\plain{\up #} _YZ4ME}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComFlowControl_XonXoffIn;XonXoffIn;XonXoffIn_Property}
{\up K}{\footnote\pard\plain{\up K} TComFlowControl,XonXoffIn;XonXoffIn;XonXoffIn,TComFlowControl}
\b\fs28\cf1 TComFlowControl.XonXoffIn\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \fs24 Enables or disables software input flow control.
\par \fs16 
\par \b\fs24 property\plain\fs24  XonXoffIn: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Specifies whether Xon/Xoff flow control is used during reception. If this property is True, the XoffChar character is sent when the input buffer comes within maximum byte limit of being full, and the XonChar character is sent when the input buffer comes within minimum byte limit of being empty.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.XonXoffOut}
{\up #}{\footnote\pard\plain{\up #} 34FKZYV}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComFlowControl_XonXoffOut;XonXoffOut;XonXoffOut_Property}
{\up K}{\footnote\pard\plain{\up K} TComFlowControl,XonXoffOut;XonXoffOut;XonXoffOut,TComFlowControl}
\b\fs28\cf1 TComFlowControl.XonXoffOut\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \fs24 Enables or disables software output flow control.
\par \fs16 
\par \b\fs24 property\plain\fs24  XonXoffOut: Boolean;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Specifies whether Xon/Xoff flow control is used during transmission. If this property is True, transmission stops when the XoffChar character is received and starts again when the XonChar character is received.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.Create}
{\up #}{\footnote\pard\plain{\up #} PHKDN3}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComFlowControl_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComFlowControl;TComFlowControl,Create}
\b\fs28\cf1 TComFlowControl.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \fs24 Creates an instance of TComFlowControl class.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  TComFlowControl.Create;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Use Create constructor to programmatically create an instance of TComFlowControl class.When object is instantiated, all flow control settings are disabled.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComFlowControl.AssignTo}
{\up #}{\footnote\pard\plain{\up #} 2JGBS8D}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AssignTo;AssignTo_Method;TComFlowControl_AssignTo}
{\up K}{\footnote\pard\plain{\up K} AssignTo;AssignTo,TComFlowControl;TComFlowControl,AssignTo}
\b\fs28\cf1 TComFlowControl.AssignTo\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComFlowControl\plain\fs20 {\v 1_L_I7P>main}
\par \pard \fs24 Handles assignments for TComFlowControl objects.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  AssignTo(Dest: TPersistent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par \fs24 Call AssignTo to copy the values of one TComFlowControl object to another.
\par \fs16 
\par \fs20 AssignTo overrides the inherited method in order to handle assignments specific to TComFlowControl objects.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComBuffer}
{\up #}{\footnote\pard\plain{\up #} 1ZPRRVU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComBuffer;TComBuffer_Object}
{\up K}{\footnote\pard\plain{\up K} TComBuffer}
\b\fs28\cf1 TComBuffer\plain\fs24 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 12HGSJ6}       \uldb Properties\plain\fs20 {\v 1N5NOW>props}       \uldb Methods\plain\fs20 {\v FS4W1U>props}
\par \pard \fs24 Defines input and ouput buffer sizes.
\par \fs16 
\par \b\fs24 Unit
\par \plain\fs24 CPort
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use TComBuffer to specify input and ouput buffer size.However, these are only recommended buffer sizes. Serial driver accepts this values, but it is free to use any other input and ouput buffer scheme.
\par \page
{\up #}{\footnote\pard\plain{\up #} 12HGSJ6}
\pard \b Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TPersistent
\par        |
\par TComBuffer
\par \page
{\up #}{\footnote\pard\plain{\up #} 1N5NOW}
\pard\keepn \b\cf1 TComBuffer properties\plain\fs24 
\par \uldb \fs20 TComBuffer\plain\fs20 {\v 1ZPRRVU>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComBuffer
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb ComPort\plain\fs20 {\v .YIPFH>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb InputSize\plain\fs20 {\v _LT9AS>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb OutputSize\plain\fs20 {\v 97F.WR>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} FS4W1U}
\pard\keepn \b\fs24\cf1 TComBufferMethods\plain\fs24 
\par \uldb \fs20 TComBuffer\plain\fs20 {\v 1ZPRRVU>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComBuffer
\par \plain\fs20 \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb AssignTo\plain\fs20 {\v 2C3T_KR>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v FQVCF6>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComBuffer.ComPort}
{\up #}{\footnote\pard\plain{\up #} .YIPFH}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComBuffer_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComBuffer;TComBuffer,ComPort}
\b\fs28\cf1 TComBuffer.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComBuffer\plain\fs20 {\v 1ZPRRVU>main}
\par \pard \fs24 Determines TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use ComPort property to determine TCustomComPort component which this class belongs to.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComBuffer.InputSize}
{\up #}{\footnote\pard\plain{\up #} _LT9AS}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} InputSize;InputSize_Property;TComBuffer_InputSize}
{\up K}{\footnote\pard\plain{\up K} InputSize;InputSize,TComBuffer;TComBuffer,InputSize}
\b\fs28\cf1 TComBuffer.InputSize\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComBuffer\plain\fs20 {\v 1ZPRRVU>main}
\par \pard \fs24 Specifies input buffer size.
\par \fs16 
\par \b\fs24 property\plain\fs24  InputSize: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use InputSize to specify the recommended size, in bytes, of the device's internal input buffer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComBuffer.OutputSize}
{\up #}{\footnote\pard\plain{\up #} 97F.WR}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} OutputSize;OutputSize_Property;TComBuffer_OuputSize}
{\up K}{\footnote\pard\plain{\up K} OutputSize;OutputSize,TComBuffer;TComBuffer,OutputSize}
\b\fs28\cf1 TComBuffer.OutputSize\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComBuffer\plain\fs20 {\v 1ZPRRVU>main}
\par \pard \fs24 Specifies output buffer size.
\par \fs16 
\par \b\fs24 property\plain\fs24  OutputSize: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use OutputSize to specify the recommended size, in bytes, of the device's internal output buffer.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComBuffer.Create}
{\up #}{\footnote\pard\plain{\up #} FQVCF6}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComBuffer_OutputSize}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComBuffer;TComBuffer,Create}
\b\fs28\cf1 TComBuffer.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComBuffer\plain\fs20 {\v 1ZPRRVU>main}
\par \pard \fs24 Creates an instance of TComBuffer class.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  TComBuffer.Create;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use Create constructor to programmatically create an instance of TComBuffer class. Create sets the following default values.
\par \pard\tx3115 \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Property\plain\fs24 \tab \tab \b Value\plain\fs24 
\par \pard\tx355 InputSize\tab \tab 1024
\par OutputSize\tab \tab 1024
\par \page
{\up $}{\footnote\pard\plain{\up $} TComBuffer.AssignTo}
{\up #}{\footnote\pard\plain{\up #} 2C3T_KR}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AssignTo;AssignTo_Method;TComBuffer_AssignTo}
{\up K}{\footnote\pard\plain{\up K} AssignTo;AssignTo,TComBuffer;TComBuffer,AssignTo}
\b\fs28\cf1 TComBuffer.AssignTo\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComBuffer\plain\fs20 {\v 1ZPRRVU>main}
\par \pard \fs24 Handles assignments for TComBuffer objects.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  AssignTo(Dest: TPersistent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par \fs24 Call AssignTo to copy the values of one TComBuffer object to another.
\par \fs16 
\par \fs20 AssignTo overrides the inherited method in order to handle assignments specific to TComBuffer objects.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity}
{\up #}{\footnote\pard\plain{\up #} XUFW7.}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComParity;TComParity_Object}
{\up K}{\footnote\pard\plain{\up K} TComParity}
\b\fs28\cf1 TComParity\plain\fs24 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v V4R9W.}       \uldb Properties\plain\fs20 {\v 1DWUZMY>props}       \uldb Methods\plain\fs20 {\v 2MYVO9M>props}
\par \pard \fs24 Defines parity checking and charachter replacing.
\par \fs16 
\par \b\fs24 Unit
\par \plain\fs24 CPort
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 TComParity object specifies parity bits, parity checking, error reporting and charachter replacement.
\par \page
{\up #}{\footnote\pard\plain{\up #} V4R9W.}
\pard \b Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TPersistent
\par        |
\par TComParity
\par \page
{\up #}{\footnote\pard\plain{\up #} 1DWUZMY}
\pard\keepn \b\cf1 TComParity properties\plain\fs24 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComParity
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Bits\plain\fs20 {\v 1EVP6DO>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Check\plain\fs20 {\v 1NN84S1>main}
\par \{bmc bm4.BMP\} \{bmc bm3.BMP\} \uldb ComPort\plain\fs20 {\v _QH6XV>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Replace\plain\fs20 {\v .8CGBU>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb ReplaceChar\plain\fs20 {\v ZWX0TZ>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} 2MYVO9M}
\pard\keepn \b\fs24\cf1 TComParity methods\plain\fs24 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComParity
\par \plain\fs20 \{bmc bm2.BMP\} \{bmc bm4.BMP\} \uldb AssignTo\plain\fs20 {\v G85QR_>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v XD_LKN>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity.ComPort}
{\up #}{\footnote\pard\plain{\up #} _QH6XV}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ComPort;ComPort_Property;TComParity_ComPort}
{\up K}{\footnote\pard\plain{\up K} ComPort;ComPort,TComParity;TComParity,ComPort}
\b\fs28\cf1 TComParity.ComPort\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}
\par \pard \fs24 Determines TCustomComPort component.
\par \fs16 
\par \b\fs24 property\plain\fs24  ComPort: TCustomComPort;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use ComPort property to determine TCustomComPort component which this class belongs to.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity.Bits}
{\up #}{\footnote\pard\plain{\up #} 1EVP6DO}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Bits;Bits_Property;TComParity_Bits}
{\up K}{\footnote\pard\plain{\up K} Bits;Bits,TComParity;TComParity,Bits}
\b\fs28\cf1 TComParity.Bits\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}
\par \pard \fs24 Specifies the parity scheme.
\par \fs16 
\par \b\fs24 type\plain\fs24  TParityBits = (prNone, prOdd, prEven, prMark, prSpace);
\par \b property\plain\fs24  Bits: TParityBits;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Specifies the parity scheme to be used. This property can be one of the following values.
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Value\plain\fs24 \tab \tab \tab \b Meaning\plain\fs24 
\par \pard\tx355 prNone\tab \tab \tab No parity
\par prOdd\tab \tab \tab Odd
\par prEven\tab \tab \tab Even
\par prMark\tab \tab \tab Mark
\par prSpace\tab \tab Space
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity.Check}
{\up #}{\footnote\pard\plain{\up #} 1NN84S1}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Check;Check_Property;TComParity_Check}
{\up K}{\footnote\pard\plain{\up K} Check;Check,TComParity;TComParity,Check;TParityBits type}
\b\fs28\cf1 TComParity.Check\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}
\par \pard \fs24 Enables or disables parity check.
\par \fs16 
\par \b\fs24 property\plain\fs24  Check: Boolean;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Specifies whether parity checking is enabled. If this property is True, parity checking is performed and errors are reported in \uldb OnError\plain\fs24 {\v 8RNVVL} event as ceRxParity error.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity.Replace}
{\up #}{\footnote\pard\plain{\up #} .8CGBU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Replace;Replace_Property;TComParity_Replace}
{\up K}{\footnote\pard\plain{\up K} Replace;Replace,TComParity;TComParity,Replace}
\b\fs28\cf1 TComParity.Replace\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}
\par \pard \fs24 Enables or disables charachter replacement.
\par \fs16 
\par \b\fs24 property\plain\fs24  Replace: Boolean;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Specifies whether bytes received with parity errors are replaced with the character specified by the \uldb ReplaceChar\plain\fs24 {\v ZWX0TZ} property. If this property is True and the \uldb Check\plain\fs24 {\v 1NN84S1} property is True, replacement occurs.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity.ReplaceChar}
{\up #}{\footnote\pard\plain{\up #} ZWX0TZ}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} ReplaceChar;ReplaceChar_Property;TComParity_ReplaceChar}
{\up K}{\footnote\pard\plain{\up K} ReplaceChar;ReplaceChar,TComParity;TComParity,ReplaceChar}
\b\fs28\cf1 TComParity.ReplaceChar\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}
\par \pard \fs24 Specifies error replacing charachter.
\par \fs16 
\par \b\fs24 property\plain\fs24  ReplaceChar: Char;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs24 Specifies the ASCII value of the character used to replace bytes received with a parity error.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity.Create}
{\up #}{\footnote\pard\plain{\up #} XD_LKN}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComParity_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComParity;TComParity,Create}
\b\fs28\cf1 TComParity.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}
\par \pard \fs24 Creates an instance of TComParity class.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  TComParity.Create;
\par \fs16 
\par \b\fs20 Description
\par \plain\fs20 Use Create constructor to programmatically create an instance of TComBuffer class. Create constructor disables parity checking and charachter replacement and sets no parity.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComParity.AssignTo}
{\up #}{\footnote\pard\plain{\up #} G85QR_}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} AssignTo;AssignTo_Method;TComParity_AssignTo}
{\up K}{\footnote\pard\plain{\up K} AssignTo;AssignTo,TComParity;TComParity,AssignTo}
\b\fs28\cf1 TComParity.AssignTo\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComParity\plain\fs20 {\v XUFW7.>main}
\par \pard \fs24 Handles assignments for TComParity objects.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  AssignTo(Dest: TPersistent); \b override\plain\fs24 ;
\par \fs16 
\par \b\fs20 Description\plain\fs20 
\par \fs24 Call AssignTo to copy the values of one TComParity object to another.
\par \fs16 
\par \fs20 AssignTo overrides the inherited method in order to handle assignments specific to TComParity objects.
\par \page
{\up $}{\footnote\pard\plain{\up $} EComPort}
{\up #}{\footnote\pard\plain{\up #} T2D5VU}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} EComPort;EComPort_Object}
{\up K}{\footnote\pard\plain{\up K} EComPort}
\b\fs28\cf1 EComPort\plain\fs20 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 12Z4CB_}       \uldb Properties\plain\fs20 {\v QI.AVG>props}       \uldb Methods\plain\fs20 {\v I2IY7Z>props}
\par \pard \fs24 EComPort is the exception class for failures on serial port.
\par \fs16 
\par \b\fs24 Unit
\par \plain\fs24 CPort
\par \fs16 
\par \b\fs24 Description
\par \plain\fs20 EComPort exception is raised on error that occurs inside TCustomComPort component. Check EComPort properties for additional information about exception.
\par \page
{\up #}{\footnote\pard\plain{\up #} 12Z4CB_}
\pard \b\fs24 Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 Exception
\par        |
\par EComPort
\par \page
{\up #}{\footnote\pard\plain{\up #} QI.AVG}
\pard\keepn \b\cf1 EComPort properties\plain\fs24 
\par \uldb \fs20 EComPort\plain\fs20 {\v T2D5VU>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In EComPort
\par \plain\fs20 \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb Code\plain\fs20 {\v SME.H1>main}
\par \{bmc bm1.BMP\} \{bmc bm4.BMP\} \uldb WinCode\plain\fs20 {\v 1.THX8K>main}
\par \page
{\up #}{\footnote\pard\plain{\up #} I2IY7Z}
\pard\keepn \b\fs24\cf1 EComPort methods\plain\fs24 
\par \uldb \fs20 EComPort\plain\fs20 {\v T2D5VU>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In EComPort
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 27ZB_R2>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb CreateNoCode\plain\fs20 {\v 1ABSXW3>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} EComPort.Code}
{\up #}{\footnote\pard\plain{\up #} SME.H1}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Code;Code_Property;EComPort_Code}
{\up K}{\footnote\pard\plain{\up K} Code;Code,EComPort;EComPort,Code}
\b\fs28\cf1 EComPort.Code\plain\fs24 
\par \fs16 
\par \uldb \fs20 EComPort\plain\fs20 {\v T2D5VU>main}
\par \pard \fs24 Specifies detailed error type.
\par \fs16 
\par \b\fs24 property\plain\fs24  Code: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Code property to obtain information about error type. See \uldb Error codes\plain\fs24 {\v YID3JB} for detailed description of error codes.
\par \page
{\up $}{\footnote\pard\plain{\up $} EComPort.WinCode}
{\up #}{\footnote\pard\plain{\up #} 1.THX8K}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} EComPort_WinCode;WinCode;WinCode_Property}
{\up K}{\footnote\pard\plain{\up K} EComPort,WinCode;WinCode;WinCode,EComPort}
\b\fs28\cf1 EComPort.WinCode\plain\fs24 
\par \fs16 
\par \uldb \fs20 EComPort\plain\fs20 {\v T2D5VU>main}
\par \pard \fs24 Specifies windows error code.
\par \fs16 
\par \b\fs24 property\plain\fs24  WinCode: Integer;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use WinCode property to get information about windows error code.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 WinCode is \b 0\plain\fs24  only when EComPort was created with \uldb CreateNoCode\plain\fs24 {\v 1ABSXW3} constructor.
\par \page
{\up $}{\footnote\pard\plain{\up $} EComPort.Create}
{\up #}{\footnote\pard\plain{\up #} 27ZB_R2}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;EComPort_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,EComPort;EComPort,Create}
\b\fs28\cf1 EComPort.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 EComPort\plain\fs20 {\v T2D5VU>main}
\par \pard \fs24 Creates an instance of EComPort exception.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(ACode: Integer; AWinCode: Integer);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Constructor Create instantiates EComPort exception. ACode parameter is a ComPort exception type. See \uldb Error codes\plain\fs24 {\v YID3JB} for detailed description of error types. AWinCode parameter is a windows error code.
\par \page
{\up $}{\footnote\pard\plain{\up $} EComPort.CreateNoCode}
{\up #}{\footnote\pard\plain{\up #} 1ABSXW3}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} CreateNoCode;CreateNoCode_Method;EComPort_CreateNoCode}
{\up K}{\footnote\pard\plain{\up K} CreateNoCode;CreateNoCode,EComPort;EComPort,CreateNoCode}
\b\fs28\cf1 EComPort.CreateNoCode\plain\fs24 
\par \fs16 
\par \uldb \fs20 EComPort\plain\fs20 {\v T2D5VU>main}
\par \pard \fs24 Creates an instance of EComPort exception.
\par \fs16 
\par \b\fs24 constructor\plain\fs24  CreateNoCode(ACode: Integer);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Constructor CreateNoCode instantiates EComPort exception. ACode parameter is a TCustomComPort exception code. See \uldb Error codes\plain\fs24 {\v YID3JB} for detailed description of error codes.
\par \fs16 
\par \b\fs24 Note
\par \plain\fs24 CreateNoCode sets WinCode property to \b 0\plain\fs24 .
\par \page
{\up $}{\footnote\pard\plain{\up $} TComStream}
{\up #}{\footnote\pard\plain{\up #} 3P7KPVE}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComStream;TComStream_Object}
{\up K}{\footnote\pard\plain{\up K} TComStream}
\b\fs28\cf1 TComStream\plain\fs24 
\par \fs16 
\par \ul \ul\fs20 Hierarchy\plain\fs20 {\v 32CURX}       \uldb Methods\plain\fs20 {\v 1H7LG74>props}
\par \pard \fs24 Stream class for com port data
\par \fs16 
\par \b\fs24 Unit
\par \plain\fs24 CPort
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use TComStream class when you want send and recieve data as a stream.\page
{\up #}{\footnote\pard\plain{\up #} 32CURX}
\pard \b Hierarchy\plain\fs24 
\par \fs16 
\par \fs24 TObject
\par        |
\par TStream
\par        |
\par TComStream
\par \page
{\up #}{\footnote\pard\plain{\up #} 1H7LG74}
\pard\keepn \b\cf1 TComStream methods\plain\fs24 
\par \uldb \fs20 TComStream\plain\fs20 {\v 3P7KPVE>main}     \ul Legend\plain\fs20 {\v 191_ZXL}
\par \pard \uldb\fs16 
\par \plain\b\fs20 In TComStream
\par \plain\fs20 \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Create\plain\fs20 {\v 19J8ND9>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Write\plain\fs20 {\v H4OER2>main}
\par \{bmc bm4.BMP\} \{bmc bm4.BMP\} \uldb Read\plain\fs20 {\v 1MHTZ81>main}
\par \page
{\up $}{\footnote\pard\plain{\up $} TComStream.Create}
{\up #}{\footnote\pard\plain{\up #} 19J8ND9}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Create;Create_Method;TComStream_Create}
{\up K}{\footnote\pard\plain{\up K} Create;Create,TComStream;TComStream,Create}
\b\fs28\cf1 TComStream.Create\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComStream\plain\fs20 {\v 3P7KPVE>main}
\par \pard \fs24 Creates and initializes com port streaming object
\par \fs16 
\par \b\fs24 constructor\plain\fs24  Create(AComPort: TCustomComPort);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Use Create constructor to instantiate TComStream object. AComPort is a TCustomComPort object that will be used in streaming methods.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComStream.Write}
{\up #}{\footnote\pard\plain{\up #} H4OER2}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} TComStream_Write;Write;Write_Method}
{\up K}{\footnote\pard\plain{\up K} TComStream,Write;Write;Write,TComStream}
\b\fs28\cf1 TComStream.Write\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComStream\plain\fs20 {\v 3P7KPVE>main}
\par \pard \fs24 Writes data to com port.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Write(\b const\plain\fs24  Buffer; Count: Longint);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Write method to send data to com port as a stream. Buffer parameter holds actual data and Count is number of bytes to be sent to com port.
\par \page
{\up $}{\footnote\pard\plain{\up $} TComStream.Read}
{\up #}{\footnote\pard\plain{\up #} 1MHTZ81}
\pard\keepn {\up A}{\footnote\pard\plain{\up A} Read;Read_Method;TComStream_Read}
{\up K}{\footnote\pard\plain{\up K} Read;Read,TComStream;TComStream,Read}
\b\fs28\cf1 TComStream.Read\plain\fs24 
\par \fs16 
\par \uldb \fs20 TComStream\plain\fs20 {\v 3P7KPVE>main}
\par \pard \fs24 Reads data from com port.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  Read(\b var\plain\fs24  Buffer; Count: Longint);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call Read method to read data from com port as a stream. Buffer will be filled with data and Count is number of bytes to be read from com port.
\par \page
{\up $}{\footnote\pard\plain{\up $} Other procedures, types and constants}
{\up #}{\footnote\pard\plain{\up #} 11Q88_S}
\pard\keepn {\up K}{\footnote\pard\plain{\up K} Other procedures, types and constants}
\b\fs28\cf1 Other procedures, types and constants\plain\fs24 
\par \fs16 
\par 
\par \pard \b\fs24 Unit
\par \plain\fs24 CPort
\par \fs16 
\par \b\fs24 Procedures
\par \uldb \plain\uldb\fs24 InitAsync\plain\fs24 {\v PIWD4U}
\par \uldb DoneAsync\plain\fs24 {\v 2_5VP2K}
\par \uldb EnumComPorts\plain\fs24 {\v 1IVFZWT}
\par \uldb Conversion functions\plain\fs24 {\v 34EH61}
\par \fs16 
\par 
\par \b\fs24 Unit
\par \plain\fs24 CPortCtl
\par \fs16 
\par \uldb \fs24 ComTerminalFont\plain\fs24 {\v 13HQI.I}
\par \page
{\up $}{\footnote\pard\plain{\up $} InitAsync procedure}
{\up #}{\footnote\pard\plain{\up #} PIWD4U}
\pard\keepn {\up K}{\footnote\pard\plain{\up K} InitAsync}
\b\fs28\cf1 InitAsync procedure\plain\fs24 
\par \fs16 
\par \fs20 
\par \pard \fs24 Inits PAsync variable.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  InitAsync(\b var\plain\fs24  AsyncPtr: PAsync);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call InitAsync procedure init PAsync type variable. PAsync type is used to identify operation in all methods that deal with asynchronous operations. After the operation is completed, application is responsible for freeing PAsync type variable with \uldb DoneAsync\plain\fs24 {\v 2_5VP2K} procedure.
\par \page
{\up $}{\footnote\pard\plain{\up $} DoneAsync procedure}
{\up #}{\footnote\pard\plain{\up #} 2_5VP2K}
\pard\keepn {\up K}{\footnote\pard\plain{\up K} DoneAsync}
\b\fs28\cf1 DoneAsync procedure\plain\fs24 
\par \fs16 
\par \fs20 
\par \pard \fs24 Frees PAsync variable.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  DoneAsync(\b var\plain\fs24  AsyncPtr: PAsync);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call DoneAsync procedure to free PAsync type variable after asynchronous operation is completed.
\par \page
{\up $}{\footnote\pard\plain{\up $} EnumComPorts procedure}
{\up #}{\footnote\pard\plain{\up #} 1IVFZWT}
\pard\keepn {\up K}{\footnote\pard\plain{\up K} EnumComPorts}
\b\fs28\cf1 EnumComPorts\plain\fs24 
\par \fs16 
\par \fs20 
\par \pard \fs24 Enumerates serial ports on local computer.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  EnumComPorts(Ports: TStrings);
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 Call EnumComPorts to fill Ports paramater with installed com ports on local computer. Ports parameter is a TString descendant created and maintained by the application. Application can assign Ports member to \uldb Port\plain\fs24 {\v 1EW3.BP} property to set port number.
\par \page
{\up $}{\footnote\pard\plain{\up $} Conversion functions}
{\up #}{\footnote\pard\plain{\up #} 34EH61}
\pard\keepn {\up K}{\footnote\pard\plain{\up K} Conversion functions}
\b\fs28\cf1 Conversion functions\plain\fs24 
\par \fs16 
\par \fs20 
\par \pard \fs24 Use these functions to easily convert one type to other.
\par \fs16 
\par \b\fs24 procedure\plain\fs24  BaudRateToStr(BaudRate: TBaudRate): \b String\plain\fs24 ;
\par \b procedure\plain\fs24  DataBitsToStr(DataBits: TDataBits): \b String\plain\fs24 ;
\par \b procedure\plain\fs24  StopBitsToStr(StopBits: TStopBits): \b String\plain\fs24 ;
\par \b procedure\plain\fs24  ParityToStr(Parity: TParityBits): \b String\plain\fs24 ;
\par \b procedure\plain\fs24  FlowControlToStr(FlowControl: TFlowControl): \b String\plain\fs24 ;
\par \fs16 
\par \b\fs24 procedure\plain\fs24  StrToBaudRate(Str: \b String\plain\fs24 ): TBaudRate;
\par \pard \b procedure\plain\fs24  StrToDataBits(Str: \b String\plain\fs24 ): TDataBits;
\par \b procedure\plain\fs24  StrToStopBits(Str: \b String\plain\fs24 ): TStopBits;
\par \b procedure\plain\fs24  StrToParity(Str: \b String\plain\fs24 ): TParityBits;
\par \b procedure\plain\fs24  StrToFlowControl(Str: \b String\plain\fs24 ): TFlowControl;
\par \page
{\up $}{\footnote\pard\plain{\up $} ComTerminalFont variable}
{\up #}{\footnote\pard\plain{\up #} 13HQI.I}
\pard\keepn {\up K}{\footnote\pard\plain{\up K} ComTerminalFont}
\b\fs28\cf1 ComTerminalFont variable\plain\fs24 
\par \fs16 
\par \fs20 
\par \pard \fs24 Default terminal font.
\par \fs16 
\par \b\fs24 var\plain\fs24  ComTerminalFont: TFont;
\par \fs16 
\par \b\fs24 Description
\par \plain\fs24 ComTerminalFont is default font fot TCustomComTerminal component and its descendants.
\par \page
{\up $}{\footnote\pard\plain{\up $} Error codes}
{\up #}{\footnote\pard\plain{\up #} YID3JB}
\pard\keepn {\up K}{\footnote\pard\plain{\up K} Error codes}
\b\fs28\cf1 Error codes\plain\fs24 
\par \fs16 
\par \fs20 
\par \pard \fs24 List of error codes
\par \fs16 
\par \pard\brdrb\brdrs\tx355 \b\fs24 Code\tab Constant\tab \tab \tab Meaning
\par \pard\tx355 \plain\fs24 1\tab CError_OpenFailed\tab \tab Failed to open serial port.
\par 2\tab CError_WriteFailed\tab \tab Error occured while writing to port.
\par 3\tab CError_ReadFailed\tab \tab Error occured while reading from port.
\par 4\tab CError_InvalidAsync\tab \tab PAsync type parameter is invalid.
\par 5\tab CError_PurgeFailed\tab \tab PurgeComm API function failed.
\par 6\tab CError_AsyncCheck\tab \tab Unable to check asynchronous operation.
\par 7\tab CError_SetStateFailed\tab \tab SetCommState API function failed.
\par 8\tab CError_TimeoutsFailed\tab \tab SetCommTimeouts API func. failed.
\par \pard\tx355 9\tab CError_SetupComFailed\tab \tab SetupComm API function failed.
\par 10\tab CError_ClearComFailed\tab \tab ClearCommError API func. failed.
\par 11\tab CError_ModemStatFailed\tab \tab GetCommModemStatus failed.
\par 12\tab CError_EscapeComFailed\tab \tab EscapeCommFunction failed.
\par 13\tab CError_TransmitFailed\tab \tab TransmitChar method failed.
\par 14\tab CError_SyncMeth\tab \tab \tab SyncMethod cannot be changed 
\par \pard\li2825\fi705\tx355 while connected.
\par \pard\tx355 15\tab CError_EnumPortsFailed\tab \tab EnumPorts function failed
\par 16\tab CError_StoreFailed\tab \tab Failed to store settings
\par 17\tab CError_LoadFailed\tab \tab Failed to load settings
\par 18\tab CError_RegFailed\tab \tab Link (un)registration failed
\par 19\tab CError_LedStateFailed\tab Cannot change led state if ComPort is 
\par \pard\li2825\fi705\tx355 selected
\par \pard\tx355 20\tab CError_ThreadCreated\tab Cannot wait for event if event thread 
\par \pard\li2825\fi705\tx355 is created
\par \pard\tx355 21\tab CError_WaitFailed\tab \tab WaitForEvent method failed
\par }